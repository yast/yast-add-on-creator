# encoding: utf-8

# ------------------------------------------------------------------------------
# Copyright (c) 2006-2012 Novell, Inc. All Rights Reserved.
#
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of version 2 of the GNU General Public License as published by the
# Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, contact Novell, Inc.
#
# To contact Novell about this file by physical or electronic mail, you may find
# current contact information at www.novell.com.
# ------------------------------------------------------------------------------

# File:	modules/AddOnCreator.ycp
# Package:	Configuration of add-on-creator
# Summary:	AddOnCreator settings, input and output functions
# Authors:	Jiri Suchomel <jsuchome@suse.cz>
#
# $Id$
#
# Representation of the configuration of add-on-creator.
# Input and output routines.
require "yast"

module Yast
  class AddOnCreatorClass < Module
    def main
      Yast.import "UI"
      textdomain "add-on-creator"

      Yast.import "Arch"
      Yast.import "Directory"
      Yast.import "FileUtils"
      Yast.import "Label"
      Yast.import "Mode"
      Yast.import "Package"
      Yast.import "PackageSystem"
      Yast.import "PackagesDescr"
      Yast.import "Progress"
      Yast.import "Report"
      Yast.import "String"

      # where the configurations are stored
      @add_on_products_file = Ops.add(Directory.vardir, "/add_on_products.ycp")

      # list of all configured AddOn products
      @add_on_products = []

      # map of the Add-On product currently in use
      @current_product = {
        # path to output directory
        "base_output_path"         => "",
        # path to directory with RPM's
        "rpm_path"                 => nil,
        # path to directory with RPM's, used only for building patterns
        # and not present on AddOn
        "required_rpm_path"        => "",
        # map of patterns for current product
        "patterns"                 => {},
        # description of packages (initially generated by create_package_descr
        "packages_descr"           => {},
        # the contents of products files
        "products_files"           => [],
        # the contents of media files
        "media_files"              => [],
        # the contents of patches files
        "patches_files"            => [],
        # the contents of info.txt file
        "info"                     => "",
        # content of readme files
        "readme_files"             => {
          "README" => ""
        },
        # content of license files (in media.1 dir)
        "license_files"            => {
          "license" => ""
        },
        "copying_files"            => { "COPYING" => "" },
        "copyright_files"          => { "COPYRIGHT" => "" },
        # the contents of EXTRA_PROV file
        "extra_prov"               => "",
        # path to the file with EXTRA_PROV data
        "extra_prov_file"          => "",
        # the contents of nextmedia file
        "nextmedia"                => "",
        # paths with packages to be archived in y2update.tgz
        "y2update_packages"        => [],
        # path with y2update.tgz (alternative to y2update_packages)
        "y2update_path"            => "",
        # path to file with installation workflow (installation.xml)
        "workflow_path"            => "",
        # if iso image should be created from the final Add-On
        "iso"                      => false,
        # where the iso image should be put
        "iso_path"                 => "",
        # name of the iso image file
        "iso_name"                 => "",
        # also sign all rpm's (see bug #287447)
        "resign_packages"          => false,
        # current GPG key
        "gpg_key"                  => "",
        # if we should generate -release package containing .prod file
        "generate_release_package" => true
      }

      # skeleton for current_product map (with keys and default values)
      @current_product_skel = deep_copy(@current_product)

      @selected_product = -1

      # variables from content file + their description
      @content = []

      @allowed_archs = [
        "ppc",
        "ppc64",
        "ia64",
        "x86_64",
        "i686",
        "i586",
        "i486",
        "i386",
        "noarch"
      ]


      @content_descr = {
        "CONTENTSTYLE" => {
          "key"       => "CONTENTSTYLE",
          # label of content file key
          "label"     => _("Content file style"),
          # help text for content file CONTENTSTYLE key
          "help"      => _(
            "Must be the first tag of the content file."
          ),
          "value"     => "11",
          "mandatory" => true
        },
        "NAME"         => {
          "key"       => "NAME",
          # label of content file key
          "label"     => _("Product name"),
          # help text for content file 'NAME' key
          "help"      => _(
            "For internal usage. Same restrictions as for package names apply."
          ),
          "mandatory" => true
        },
        "BASEARCHS"    => {
          "key"       => "BASEARCHS",
          # label of content file BASEARCHS key
          "label"     => _(
            "Product architectures"
          ),
          # help text for content file 'BASEARCHS' key
          "help"      => _(
            "Space-separated list of product architectures. Matches the available product-release packages architectures. "
          ),
          "mandatory" => true
        },
        "VERSION"      => {
          "key"       => "VERSION",
          # label of content file 'VERSION' key
          "label"     => _(
            "Product version and release"
          ),
          # help text for content file 'VERSION' key
          "help"      => _(
            "Product version and release as in RPM <tt>major.minor-release</tt>."
          ),
          "value"     => "1",
          "mandatory" => true
        },
        "RELEASE"      => {
          "key"       => "RELEASE",
          # table item label
          "label"     => _("Release number"),
          "value"     => "0",
          "mandatory" => true
        },
        "DISTRIBUTION" => {
          "key"   => "DISTRIBUTION",
          # label of content file key
          "label" => _("Distribution name"),
          # help text for content file 'DISTRIBUTION' key
          "help"  => _(
            "Some string denoting the distribution. The same string is most probably used in the .rpms to denote the distribution. Usually a composition of the name, version and architecture."
          )
        },
        "DESCRDIR"     => {
          "key"       => "DESCRDIR",
          # label of content file key
          "label"     => _(
            "Package description directory"
          ),
          "value"     => "suse/setup/descr",
          # help text for content file 'DESCRDIR' key
          "help"      => _(
            "Package description directory (relative to product directory)."
          ),
          "mandatory" => true
        },
        "DATADIR"      => {
          "key"       => "DATADIR",
          # label of content file key
          "label"     => _("Package data directory"),
          # help text for content file 'DATADIR' key
          "help"      => _(
            "Package data directory (relative to product directory)."
          ),
          "value"     => "suse",
          "mandatory" => true
        },
        "LABEL"        => {
          "key"   => "LABEL",
          # label of content file key
          "label" => _("Label"),
          # help text for content file '' key
          "help"  => _(
            "UTF-8 encoded label. Default label if <b>LINGUAS</b> is omitted or no default language can be determined."
          )
        },
        "LINGUAS"      => {
          "key"   => "LINGUAS",
          # label of content file 'LINGUAS' key
          "label" => _("Languages"),
          # help text for content file 'LINGUAS' key
          "help"  => _(
            "ISO language code or language code_country code."
          )
        },
        "LANGUAGE"     => {
          "key"            => "LANGUAGE",
          # label of content file 'LANGUAGE' key
          "label"          => _(
            "Default language"
          ),
          # help text for content file 'LANGUAGE' key
          "help"           => _(
            "Default language code."
          ),
          "type"           => "combo",
          "allowed_values" => nil
        },
        "PATTERNS"     => {
          "key"   => "PATTERNS",
          # label of content file 'PATTERNS' key
          "label" => _(
            "Preselected patterns"
          ),
          # help text for content file 'PATTERNS' key
          "help"  => _(
            "List of patterns preselected by the product."
          )
        },
        "VENDOR"       => {
          "key"       => "VENDOR",
          # label of content file key
          "label"     => _("Vendor name"),
          # help text for content file 'VENDOR' key
          "help"      => _(
            "Vendor name (free form)."
          ),
          "mandatory" => true
        },
        "RELNOTESURL"  => {
          "key"   => "RELNOTESURL",
          # label of content file 'RELNOTESURL' key
          "label" => _(
            "Release notes URL"
          ),
          # help text for content file 'RELNOTESURL' key
          "help"  => _(
            "URL from which to fetch release notes."
          )
        },
        "UPDATEURLS"   => {
          "key"   => "UPDATEURLS",
          # label of content file 'UPDATEURLS' key
          "label" => _("Update URL"),
          # help text for content file 'UPDATEURLS' key
          "help"  => _(
            "URL of the update source."
          )
        }
      }

      # skeletons for special keys in content file
      @content_specials = {
        "LABEL" => {
          # label of content file LABEL.lang key
          "label"     => _(
            "Language-specific label"
          ),
          # help text for content file 'LABEL.lang' key
          "help"      => _(
            "UTF-8-encoded <b>LABEL</b>. <tt>lang</tt> has the same syntax as the <b>LINGUAS</b> values. For each language in <b>LINGUAS</b>, a matching <b>LABEL.lang</b> is expected."
          ),
          "helplabel" => "LABEL.lang"
        }
      }


      # desctiption of pattern keys
      @pattern_descr = {
        "name"    => { "internal" => true },
        "version" => {
          "label"      => _("Version"),
          "internal"   => true,
          "adapt_name" => true,
          "defval"     => "1.0"
        },
        "release" => {
          "label"      => _("Release"),
          "internal"   => true,
          "adapt_name" => true,
          "defval"     => "1"
        },
        "arch"    => {
          "label"          => _("Architecture"),
          "internal"       => true,
          "type"           => "combo",
          "allowed_values" => @allowed_archs,
          "adapt_name"     => true,
          "defval"         => "noarch"
        },
        "Pat"     => { "single_line" => true },
        "Ver"     => { "defval" => "5.0", "single_line" => true },
        "Sum"     => {
          "label"       => _("Summary"),
          # help text for 'Sum' pattern key
          "help"        => _(
            "One line label in the default language"
          ),
          # help text for 'Sum.lang' pattern key
          "lang_help"   => _(
            "One line language-specific label."
          ),
          "single_line" => true
        },
        "Des"     => {
          # label for 'Des' pattern key
          "label"     => _("Description"),
          "type"      => "multiline",
          # help text for 'Des' pattern key
          "help"      => _(
            "Multiple line description in the default language"
          ),
          # help text for 'Des.lang' pattern key
          "lang_help" => _(
            "Multiple line description, language-specific."
          )
        },
        "Cat"     => {
          # label for 'Cat' pattern key
          "label"       => _("Category"),
          # help text for 'Cat' pattern key
          "help"        => _(
            "One line category in the default language used to group patterns. Categories are intended for the user and can be specified freely."
          ),
          # help text for 'Cat.lang' pattern key
          "lang_help"   => _(
            "Language-specific version of the category."
          ),
          "single_line" => true
        },
        "Vis"     => {
          # label for 'Vis' pattern key
          "label"       => _("Visibility"),
          # help text for 'Vis' pattern key
          "help"        => _(
            "Set whether the pattern should be visible in the user interface."
          ),
          "type"        => "boolean",
          "defval"      => true,
          "single_line" => true
        },
        "Prq"     => {
          # label for 'Prq' pattern key
          "label"  => _("Packages"),
          # help text for 'Prq' pattern key
          "help"   => _(
            "List of packages to install."
          ),
          "type"   => "package-list",
          "defval" => []
        },
        "Prc"     => {
          # label for 'Prc' pattern key
          "label"  => _("Recommended packages"),
          # help text for 'Prc' pattern key
          "help"   => _(
            "These packages are installed by default but can be removed without complaint."
          ),
          "type"   => "package-list",
          "defval" => []
        },
        "Psg"     => {
          # label for 'Prs' pattern key
          "label"  => _("Suggested packages"),
          # help text for 'Prs' pattern key
          "help"   => _(
            "These are just hints for an application and not handled during dependency resolution."
          ),
          "type"   => "package-list",
          "defval" => []
        },
        "Ico"     => {
          # label for 'Ico' pattern key
          "label"       => _("Icon filename"),
          # help text for 'Ico' pattern key
          "help"        => _(
            "If unspecified, the pattern name is used \n instead (with blanks in the name replaced by underscores). If the filename does not include a .png or .jpg extension, .png is appended. If no path is specified, icons are searched for in the theme icon path (first /usr/share/YaST2/theme/current/icons/32x32/apps/ then /usr/share/YaST2/theme/current/icons/48x48/apps/). Absolute and relative paths (to the theme path /usr/share/YaST2/theme/current/) are allowed."
          ),
          "type"        => "file-name",
          "defval"      => "",
          "single_line" => true
        },
        "Ord"     => {
          # label for 'Ord' pattern key
          "label"       => _("Pattern Order"),
          # help text for 'Ord' pattern key
          "help"        => _(
            "This three-digit integer value defines the order of the pattern when listing multiple patterns in the user interface."
          ),
          "defval"      => "",
          "single_line" => true,
          "type"        => "integer",
          "range"       => [100, 9999]
        },
        "Req"     => {
          # label for 'Req' pattern key
          "label"  => _("Required patterns"),
          # help text for 'Req' pattern key
          "help"   => _(
            "Patterns that need to be installed together with this pattern."
          ),
          "defval" => "",
          "type"   => "pattern-list"
        },
        "Prv"     => {
          # label for 'Prv' pattern key
          "label"  => _("Provided patterns"),
          # help text for 'Prv' pattern key
          "help"   => _(
            "Capabilities this pattern provides. They can be used to match <b>REQUIRES</b> from others. Every resolvable has a provide by default--its own name and edition. For example, package <i>bar-1.42-1</i> provides the capability <tt>bar = 1.42-1</tt>."
          ),
          "defval" => "",
          "type"   => "pattern-list"
        },
        "Con"     => {
          # label for 'Con' pattern key
          "label"  => _("Conflicting patterns"),
          # help text for 'Con' pattern key
          "help"   => _(
            "This pattern cannot be installed if the specified resolvable or one that provides the capability is installed."
          ),
          "defval" => "",
          "type"   => "pattern-list"
        },
        "Obs"     => {
          # label for 'Obs' pattern key
          "label"  => _("Patterns made obsolete"),
          # help text for 'Obs' pattern key
          "help"   => _(
            "When this pattern is installed, it uninstalls any \nother patterns marked as obsolete here."
          ),
          "defval" => "",
          "type"   => "pattern-list"
        },
        "Rec"     => {
          # label for 'Rec' pattern key
          "label"  => _("Recommended patterns"),
          # help text for 'Rec' pattern key
          "help"   => _(
            "A weak version of REQUIRES. If recommended patterns cannot be installed, no error is shown."
          ),
          "defval" => "",
          "type"   => "pattern-list"
        },
        "Sup"     => {
          # label for 'Sup' pattern key
          "label"  => _("Supplemented patterns"),
          # help text for 'Sup' pattern key
          "help"   => _(
            "A reverse <b>Rec</b>. This pattern is installed if the specified capability is provided by an installed resolvable. The dependency resolver installs it. Uninstalling it is silently accepted."
          ),
          "defval" => "",
          "type"   => "pattern-list"
        },
        "Sug"     => {
          # label for 'Sug' pattern key
          "label"  => _("Suggested patterns"),
          # help text for 'Sug' pattern key
          "help"   => _(
            "These are just hints for an application and not handled during dependency resolution."
          ),
          "defval" => "",
          "type"   => "pattern-list"
        },
        "Fre"     => {
          # label for 'Fre' pattern key
          "label"  => _("Freshen"),
          # help text for 'Fre' pattern key
          "help"   => _(
            "The current pattern is only considered for installation if the pattern specified here is installed."
          ),
          "defval" => "",
          "type"   => "pattern-list"
        },
        # TODO during editing, remove from Prc and Prs packages contained in Prq
        # TODO add some key for sorting, so output file is readable
        "Ext"     => {
          # label for 'Ext' pattern key
          "label"  => _("Extends"),
          "defval" => "",
          "type"   => "pattern-list"
        },
        "Inc"     => {
          # label for 'Inc' pattern key
          "label"  => _("Includes"),
          "defval" => "",
          "type"   => "pattern-list"
        },
        "Enh"     => {
          # label for 'Exnh pattern key
          "label"  => _("Enhanced patterns"),
          "defval" => "",
          "type"   => "pattern-list"
        },
        "Pcn"     => {
          # label for 'Pcn' pattern key
          "label"  => _("Conflicting packages"),
          "type"   => "package-list",
          "defval" => []
        },
        "Pob"     => {
          # label for 'Pob' pattern key
          "label"  => _("Obsolete packages"),
          "type"   => "package-list",
          "defval" => []
        },
        "Pfr"     => {
          # label for 'Pfr' pattern key
          "label"  => _("Freshened packages"),
          "type"   => "package-list",
          "defval" => []
        },
        "Psp"     => {
          # label for 'Psp' pattern key
          "label"  => _("Supplemented packages"),
          "type"   => "package-list",
          "defval" => []
        },
        "Pen"     => {
          # label for 'Pen' pattern key
          "label"  => _("Enhanced packages"),
          "type"   => "package-list",
          "defval" => []
        }
      }

      # description of keys in package description files
      @description_descr = {
        "Pkg" => {
          # label for 'Pkg' key
          "label" => _("Package")
        },
        "Des" => {
          # label for 'Des' key
          "label"  => _("Description"),
          # help text for 'Des' key
          "help"   => _(
            "Multiple line package description."
          ),
          "type"   => "multiline",
          "defval" => "-"
        },
        "Sum" => {
          # label for 'Sum' key
          "label"       => _("Summary"),
          # help text for 'Sum' key
          "help"        => _(
            "The package summary (label), a one line description of the package."
          ),
          "single_line" => true,
          "defval"      => "-"
        },
        "Ins" => {
          # label for 'Ins' key
          "label" => _("Installation Notification"),
          # help text for 'Ins' key
          "help"  => _(
            "An informal message shown to the user if the package is selected, such as a test version warning or a commercial license."
          ),
          "type"  => "multiline"
        },
        "Del" => {
          # label for 'Del' key
          "label" => _("Deletion Notification"),
          # help text for 'Del' key
          "help"  => _(
            "An informal message shown to the user if the package is selected for deletion, such as a warning that the system is unusable without the package."
          ),
          "type"  => "multiline"
        },
        "Eul" => {
          # label for 'Eul' key
          "label" => _("EULA"),
          # help text for 'Eul' key
          "help"  => _(
            "Text of the EULA. This text is displayed before the package installation. If the user does not accept the EULA, the package is not installed."
          ),
          "type"  => "multiline"
        }
      }

      # script used for signing rpm's
      @expect_script = "#!/usr/bin/expect --\n" +
        "exp_internal 0\n" +
        "\n" +
        "set stat 0\n" +
        "foreach rpm $argv {\n" +
        "    spawn -noecho rpm --delsign $rpm\n" +
        "    expect {\n" +
        "\teof {}\n" +
        "    }\n" +
        "    spawn -noecho rpm --define \"_signature gpg\" --define \"_gpg_name %1\" --define \"_gpgbin /usr/bin/gpg\" --resign $rpm\n" +
        "    expect \"pass phrase:\" {send \"%2 \"}\n" +
        "    expect {\n" +
        "\t\"is good.\" {send \"\n" +
        "\"}\n" +
        "\teof {}\n" +
        "    }\n" +
        "    wait\n" +
        "    spawn -noecho rpm --define \"_signature gpg\" --define \"_gpg_name %1\" --define \"_gpgbin /usr/bin/gpg\" --checksig $rpm\n" +
        "    expect {\n" +
        "\t-re \": .*(gpg|pgp).*OK\" {continue;}\n" +
        "\teof      {set stat 1;}\n" +
        "    }\n" +
        "}\n" +
        "exit $stat"

      # just key:value mapping based on content list
      @content_map = {}

      # info for product.xml
      @product_info_descr = {
        "requires"      => {
          "key"   => "requires",
          # label of key
          "label" => _("Products that must be installed"),
          # help text for 'REQUIRES' key
          "help"  => _(
            "<p>Resolvables that must be installed on the system to meet product requirements.</p>"
          ),
          "type"  => "dependency"
        },
        "provides"      => {
          "key"   => "provides",
          # label of PROVIDES key
          "label" => _("Provided products"),
          # help text for 'PROVIDES' key
          "help"  => _(
            "Capabilities this product provides. They can be used to match <b>requires</b> from others."
          ),
          "type"  => "dependency"
        },
        "conflicts"     => {
          "key"   => "conflicts",
          # label of 'CONFLICTS' key
          "label" => _("Conflicting products"),
          # help text for 'CONFLICTS' key
          "help"  => _(
            "This resolvable cannot be installed if the specified resolvable or one that provides the capability is installed."
          ),
          "type"  => "dependency"
        },
        "obsoletes"     => {
          "key"   => "obsoletes",
          # label of 'OBSOLETES' key
          "label" => _("Products made obsolete"),
          # help text for 'OBSOLETES' key
          "help"  => _(
            "When this resolvable is installed, it uninstalls any other resolvable with a name matching this keyword."
          ),
          "type"  => "dependency"
        },
        "recommends"    => {
          "key"   => "recommends",
          # label of 'RECOMMENDS' key
          "label" => _("Recommended products"),
          # help text for 'RECOMMENDS' key
          "help"  => _(
            "A weak version of <b>requires</b>. An attempt is made to fulfill <b>RECOMMENDS</b>, but they are silently ignored if no match is possible."
          ),
          "type"  => "dependency"
        },
        "suggests"      => {
          "key"   => "suggests",
          # label of 'SUGGESTS' key
          "label" => _("Suggested products"),
          # help text for 'SUGGESTS' key
          "help"  => _(
            "These are just hints for an application and not handled during dependency resolution."
          ),
          "type"  => "dependency"
        },
        "release"       => {
          "key"   => "release",
          # table item label
          "label" => _("Release number")
        },
        "releasenotes"  => {
          "key"   => "releasenotes",
          # table item label
          "label" => _("The URL for release notes RPM")
        },
        "description"   => {
          "key"   => "description",
          # table item label
          "label" => _("Product description")
        },
        "patchlevel"    => {
          "key"   => "patchlevel",
          # table item label
          "label" => _("Patch level")
        },
        "summary"       => {
          "key"   => "summary",
          # table item label
          "label" => _("Product summary")
        },
        "productline"   => {
          "key"   => "productline",
          # table item label
          "label" => _("Product line"),
          # help text for 'productline' key
          "help"  => _(
            "A short name for the product, which does not change between service packs and versions."
          )
        },
        "updaterepokey" => {
          "key"   => "updaterepokey",
          # table item label
          "label" => _("Update repository key")
        },
        "media type"    => {
          "key"   => "media type",
          # table item label
          "label" => _("Type of media"),
          # help text for media type
          "help"  => _(
            "Type of media that will be used for target product. Possible values are: cd, ftp, dvd5, dvd9."
          )
        },
        "flavor"        => {
          "key"   => "flavor",
          # table item label
          "label" => _("Product flavor"),
          # help text for media type
          "help"  => _(
            "Description of the flavor or variant of a product, e.g. DVD, FTP, Live"
          )
        }
      }

      # save the structure of product_info, but not the values
      @product_info = {}

      # the content of .prod file, as read using any_xml agent
      @product_xml = {}


      # if we have 'source add-on' to base the new one on
      @clone = false

      # path to directory with existing product (which is being cloned)
      @import_path = ""

      # if the descriptions of packages should be generated
      # (false have only sense when cloning where they could be read from
      # description files of cloned product)
      @generate_descriptions = false

      # if final Add-On should be bootable (feature not implemented)
      @bootable = false

      # tmp directory
      @tmpdir = ""

      # full paths to media directories (media.n)
      @full_media_paths = []

      # architecture specific directory names of target product
      @arch_directories = []

      # full path to descr directory
      @full_descr_path = ""

      # full path to data directory
      @full_data_path = ""

      # current GPG key
      #global string gpg_key	= "";

      # passphrases to unlock secret key (mapping GPG key:pass)
      @passphrases = {}

      @gpg_keys = []

      # packages from current AddOn available for the pattern
      @available_packages = {}

      # mapping of package name to full file name
      @package2filename = {}

      # mapping of source package name to full file name
      @srcpackage2filename = {}

      # if we want only to sign existing product (and possibly create iso of it)
      @only_sign_product = false

      # if pattern files should be compressed
      @compress_patterns = false

      # if pattern definitions should be merged into one file TODO
      @merge_patterns = false

      # if package description files should be compressed
      @compress_package_descriptions = false

      # Data was modified?
      @modified = false

      @gzip_is_installed = nil

      @lang_codes = { "languages" => nil, "with_country" => nil }

      # argument for any_xml agent: key indicating content of element without
      # attributes
      @content_key = "__yast_content__"
    end

    def gzip_installed
      if @gzip_is_installed == nil
        @gzip_is_installed = Package.Installed("gzip")
      end
      @gzip_is_installed
    end

    # Data was modified?
    # @return true if modified
    def Modified
      Builtins.y2debug("modified=%1", @modified)
      @modified
    end


    # import the data from given xml file
    # @param path to .prod file
    # @ret map of imported data
    def ReadProductXML(prod_file_path)
      ret = {}
      if !FileUtils.Exists(prod_file_path)
        Builtins.y2warning("no such file %1", prod_file_path)
        return deep_copy(ret)
      end

      # read rest of config.xml using more generic agent
      anyxml = Convert.to_map(
        SCR.Read(
          path(".anyxml"),
          {
            "file" => prod_file_path,
            "args" => {
              "ForceArray"   => 1,
              "KeepRoot"     => 1,
              "KeyAttr"      => [],
              "ForceContent" => 1,
              "ContentKey"   => @content_key
            }
          }
        )
      )
      ret = Convert.convert(anyxml, :from => "map", :to => "map <string, any>")
      deep_copy(ret)
    end

    # Get the map describing product.xml and produce better readable YCP map
    # @param [Hash] xml map as read from xml file (from ReadProductXML)
    # @param if the values in new ProductInfo map should be merged with current one
    # (only changes are written when saving project, this means 'apply changes')
    def GetProductInfo(xml, merge_with_current)
      xml = deep_copy(xml)
      # (because it is 'merge_with_current', product_info can
      # be used as global variable, reflecting current state)
      retmap = merge_with_current ?
        deep_copy(@product_info) :
        deep_copy(@product_info_descr)
      prod_map = {}
      if Ops.greater_than(
          Builtins.size(
            Ops.get_list(xml, ["productdefinition", 0, "products"], [])
          ),
          0
        )
        prod_map = Ops.get_map(
          xml,
          ["productdefinition", 0, "products", 0, "product", 0],
          {}
        )
      else
        prod_map = Ops.get_map(xml, ["product", 0], {})
      end # maso, ze?

      # only simple values are supported here, something nested
      # deeper (e.g. linguas) will not work
      Builtins.foreach(retmap) do |key, desc|
        if Builtins.haskey(prod_map, key)
          val = Ops.get_string(prod_map, [key, 0, @content_key], "")
          if val != ""
            if merge_with_current
              # set the new value only when there is nothing
              # present in product_info[key]:
              # in case we are editing existing add-on product
              # configuration, there can be some modifications
              # saved, and they are preferred
              if Ops.get_string(retmap, [key, "value"], "") == ""
                Ops.set(retmap, [key, "value"], val)
              else
                # manual modifications present -> generate
                # this is used when product xml was read from rpm
                Ops.set(@current_product, "generate_release_package", true)
              end
            else
              Ops.set(retmap, [key, "value"], val)
            end
          end
        end
      end
      # ok, let's try to read at least release notes url
      Builtins.foreach(Ops.get_list(prod_map, ["urls", 0, "url"], [])) do |url|
        if Ops.get_string(url, "name", "") == "releasenotes"
          if !merge_with_current ||
              Ops.get_string(retmap, ["releasenotes", "value"], "") == ""
            Ops.set(
              retmap,
              ["releasenotes", "value"],
              Ops.get_string(url, @content_key, "")
            )
          end
        end
      end
      # read the product dependencies which may be in mediasets section
      mediamap = Ops.get_map(
        xml,
        ["productdefinition", 0, "mediasets", 0, "media", 0],
        {}
      )
      Builtins.foreach(Ops.get_list(mediamap, "productdependency", [])) do |dep|
        key = Ops.get_string(dep, "relationship", "")
        if Ops.get_list(retmap, [key, "value"], []) == []
          Ops.set(retmap, [key, "value"], [])
        end
        Ops.set(
          retmap,
          [key, "value"],
          Builtins.add(
            Ops.get_list(retmap, [key, "value"], []),
            Builtins.remove(dep, "relationship")
          )
        )
      end
      # flavor may be in mediasets section
      if !merge_with_current &&
          Ops.get_string(retmap, ["flavor", "value"], "") == ""
        if Ops.get_string(mediamap, "flavor", "") != ""
          Ops.set(
            retmap,
            ["flavor", "value"],
            Ops.get_string(mediamap, "flavor", "")
          )
        end
      end
      Builtins.y2milestone("product_info: %1", retmap)
      deep_copy(retmap)
    end

    # Take list of content-file data and update global content_map.
    # If argument is empty, global 'content' list is used as an input.
    def UpdateContentMap(content_list)
      content_list = deep_copy(content_list)
      if content_list == nil || content_list == []
        content_list = deep_copy(@content)
      end
      Builtins.foreach(content_list) do |entry|
        if Ops.get_string(entry, "value", "") != ""
          Ops.set(
            @content_map,
            Ops.get_string(entry, "key", ""),
            Ops.get_string(entry, "value", "")
          )
        end
      end
      deep_copy(@content_map)
    end


    # return list of language codes, optionally together with country code
    def GetLangCodes(country)
      key = country ? "with_country" : "languages"
      cut = country ? "cut -f 1 -d . | cut -f 1 -d @" : "cut -f 1 -d _"
      if Ops.get(@lang_codes, key) == nil
        out = Convert.to_map(
          SCR.Execute(
            path(".target.bash_output"),
            Ops.add("locale -a | ", cut),
            { "LANG" => "C" }
          )
        )
        Ops.set(
          @lang_codes,
          key,
          Builtins.filter(
            Builtins.toset(
              Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
            )
          ) { |l| l != "" && l != "C" && l != "POSIX" }
        )
      end
      Ops.get_list(@lang_codes, key, [])
    end

    # if file is true, it creates the file name for the pattern, otherwise
    # the Pat value
    def CreatePatternFullName(pattern, file)
      pattern = deep_copy(pattern)
      Builtins.sformat(
        "%1%5%2%5%3%6%4%7",
        Ops.get_string(pattern, "name", ""),
        Ops.get_string(pattern, "version", ""),
        Ops.get_string(pattern, "release", ""),
        Ops.get_string(pattern, "arch", ""),
        file ? "-" : " ",
        file ? "." : " ",
        file ? ".pat" : ""
      )
    end

    # read the list of available secret keys
    def read_secret_keys
      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          "gpg --list-secret-keys|grep '^sec'|sed -e 's/.*\\///;s/ .*//g;'"
        )
      )
      Builtins.filter(
        Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
      ) { |k| k != "" }
    end


    # Generate the key pair
    def GenerateGPGKey(data)
      data = deep_copy(data)
      data_cont = Builtins.sformat(
        "Key-Type: %1\n",
        Ops.get(data, "Key-Type", "")
      )
      data = Builtins.remove(data, "Key-Type")
      Builtins.foreach(data) do |key, val|
        if val != ""
          data_cont = Ops.add(data_cont, Builtins.sformat("%1: %2\n", key, val))
        end
      end

      # save the needed data to file
      data_path = Ops.add(@tmpdir, "/gen-key-data")
      SCR.Write(path(".target.string"), data_path, data_cont)

      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Ops.add("gpg --batch --gen-key ", data_path)
        )
      )
      if Ops.get_integer(out, "exit", 0) != 0
        Builtins.y2warning("error calling gpg: %1", out)
        return ""
      end

      SCR.Execute(path(".target.remove"), data_path)

      @gpg_keys = read_secret_keys
      Ops.get(@gpg_keys, Ops.subtract(Builtins.size(@gpg_keys), 1), "")
    end

    # Initialize the settings for add-on-creator
    # @return true on success
    def Read
      if !PackageSystem.CheckAndInstallPackagesInteractive(
          ["inst-source-utils"]
        )
        return false
      end

      @gpg_keys = read_secret_keys

      out = Convert.to_map(
        SCR.Execute(path(".target.bash_output"), "/usr/bin/id --user")
      )
      if Ops.get_string(out, "stdout", "") != "0\n" &&
          Ops.get_string(out, "stdout", "") != ""
        out = Convert.to_map(
          SCR.Execute(path(".target.bash_output"), "echo $HOME")
        )
        home = Builtins.getenv("HOME")
        if home != "" && home != nil
          @add_on_products_file = Ops.add(home, "/add_on_products.ycp")
        end
      end

      # Read the info of configured AddOns
      if FileUtils.Exists(@add_on_products_file)
        all_products = Convert.convert(
          SCR.Read(path(".target.ycp"), @add_on_products_file),
          :from => "any",
          :to   => "list <map>"
        )
        @add_on_products = deep_copy(all_products) if all_products != nil
      else
        Ops.set(@current_product, "gpg_key", Ops.get(@gpg_keys, 0, ""))
      end
      # fill uninitialized values in content descriptions
      i = 0

      Builtins.foreach(@content_descr) do |key, entry|
        if Ops.get(entry, "allowed_values") == nil
          # TODO add a handlers for filling the values
          if key == "LANGUAGE"
            Ops.set(@content_descr, [key, "allowed_values"], GetLangCodes(true))
          else
            Ops.set(@content_descr, [key, "allowed_values"], [])
          end
        end
        if key == "DEFAULTBASE"
          Ops.set(@content_descr, [key, "value"], Arch.architecture)
        end
        defval = Convert.to_string(
          SCR.Read(Builtins.add(path(".sysconfig.add-on-creator"), key))
        )
        if defval != nil && defval != ""
          Builtins.y2milestone("using default value for %1: %2", key, defval)
          Ops.set(@content_descr, [key, "value"], defval)
        end
        i = Ops.add(i, 1)
      end

      @tmpdir = Directory.tmpdir

      if SCR.Read(path(".sysconfig.add-on-creator.COMPRESS_PATTERNS")) == "yes"
        @compress_patterns = true
      end

      if SCR.Read(
          path(".sysconfig.add-on-creator.COMPRESS_PACKAGE_DESCRIPTIONS")
        ) == "yes"
        @compress_package_descriptions = true
      end

      if @product_xml == {}
        # read the template file
        @product_xml = ReadProductXML(
          Ops.add(Directory.datadir, "/add-on-creator/template.prod")
        )
      end

      # fill the inital values
      @product_info = deep_copy(@product_info_descr)
      true
    end

    # read the content file given by file name
    def ReadContentFile(file_path)
      ret = []

      Builtins.y2milestone("Importing content file '%1'", file_path)

      SCR.RegisterAgent(
        path(".content"),
        term(
          :ag_ini,
          term(
            :IniAgent,
            file_path,
            {
              "options"  => ["global_values", "flat"],
              "comments" => ["^#.*", "^[ \t]*$"],
              "params"   => [
                {
                  "match" => [
                    "^[ \t]*([a-zA-Z0-9_.]+)[ \t]+(.*[^ \t]|)[ \t]*$",
                    "%s %s"
                  ]
                }
              ]
            }
          )
        )
      )

      keys = SCR.Dir(path(".content"))
      Builtins.foreach(keys) do |key|
        val = Convert.to_string(SCR.Read(Builtins.add(path(".content"), key)))
        next if val == nil
        entry = Ops.get(@content_descr, key, {})
        if entry == {} && Builtins.issubstring(key, ".")
          entry = Ops.get_map(
            @content_specials,
            Builtins.substring(key, 0, Builtins.findfirstof(key, ".")),
            {}
          )
        end
        if entry != {}
          Ops.set(entry, "key", key)
          Ops.set(entry, "value", val)
          ret = Builtins.add(ret, entry)
          Ops.set(@content_map, key, val)
        end
      end
      SCR.UnregisterAgent(path(".content"))

      # + fill the rest
      Builtins.foreach(@content_descr) do |key, entry|
        ret = Builtins.add(ret, entry) if !Builtins.contains(keys, key)
      end

      deep_copy(ret)
    end

    # Take a path to compressed file as argument and return path to uncompressed one\
    def uncompress_file(file_path)
      ret = file_path
      if Builtins.substring(
          file_path,
          Ops.subtract(Builtins.size(file_path), 3),
          3
        ) == ".gz" &&
          gzip_installed
        full = Builtins.splitstring(file_path, "/")
        file = Ops.get_string(full, Ops.subtract(Builtins.size(full), 1), "")
        if !FileUtils.Exists(Ops.add(Ops.add(@tmpdir, "/"), file))
          SCR.Execute(
            path(".target.bash"),
            Builtins.sformat("cp -- %1 %2/", file_path, @tmpdir)
          )
        end
        o = Convert.to_map(
          SCR.Execute(
            path(".target.bash_output"),
            Builtins.sformat("cd %1; gunzip %2", @tmpdir, file)
          )
        )
        if Ops.get_integer(o, "exit", 1) == 0
          ret = Ops.add(
            Ops.add(@tmpdir, "/"),
            Builtins.substring(file, 0, Ops.subtract(Builtins.size(file), 3))
          )
        else
          Builtins.y2warning(
            "gunzip failed with %1 (%2)",
            Ops.get_integer(o, "exit", 0),
            Ops.get_string(o, "stderr", "")
          )
        end
      end
      ret
    end

    # read the pattern given by file name (obsolete, use ReadPatternsFile instead)
    def ReadPatternFile(file_path)
      Builtins.y2milestone("Importing pattern '%1'", file_path)
      file_path = uncompress_file(file_path)

      ret = {}
      pt = Convert.to_map(SCR.Read(path(".pattern"), file_path))

      Builtins.foreach(
        Convert.convert(pt, :from => "map", :to => "map <string, any>")
      ) do |key, val|
        if Ops.get_string(@pattern_descr, [key, "type"], "") == "package-list"
          Ops.set(
            ret,
            key,
            Builtins.splitstring(Builtins.sformat("%1", val), "\n")
          )
          # make the packages included in imported pattern available for UI
          Ops.set(
            @available_packages,
            "ZZZ_imported",
            Builtins.union(
              Ops.get(@available_packages, "ZZZ_imported", []),
              Ops.get_list(ret, key, [])
            )
          )
        else
          Ops.set(ret, key, val)
        end
      end
      Builtins.foreach(@pattern_descr) do |key, descr|
        if !Builtins.haskey(ret, key) &&
            !Ops.get_boolean(descr, "internal", false)
          Builtins.y2debug("adding empty key '%1'...", key)
          # do not add default values - maybe imported pattern
          # ignored them intentionally
          Ops.set(ret, key, "")
        end
      end
      deep_copy(ret)
    end

    # read all the patterns defined in given file
    # @return [Array] of pattern maps
    def ReadPatternsFile(file_path)
      Builtins.y2milestone("Importing pattern '%1'", file_path)
      file_path = uncompress_file(file_path)

      retlist = []
      pts = Convert.convert(
        SCR.Read(path(".pattern.list"), file_path),
        :from => "any",
        :to   => "list <map>"
      )

      Builtins.foreach(pts) do |pt|
        ret = {}
        Builtins.foreach(
          Convert.convert(pt, :from => "map", :to => "map <string, any>")
        ) do |key, val|
          if Ops.get_string(@pattern_descr, [key, "type"], "") == "package-list"
            Ops.set(
              ret,
              key,
              Builtins.splitstring(Builtins.sformat("%1", val), "\n")
            )
            # make the packages included in pattern available for UI
            Ops.set(
              @available_packages,
              "ZZZ_imported",
              Builtins.union(
                Ops.get(@available_packages, "ZZZ_imported", []),
                Ops.get_list(ret, key, [])
              )
            )
          else
            Ops.set(ret, key, val)
          end
        end
        # add empty values for keys not present in imported pattern
        Builtins.foreach(@pattern_descr) do |key, descr|
          if !Builtins.haskey(ret, key) &&
              !Ops.get_boolean(descr, "internal", false)
            Builtins.y2debug("adding empty key '%1'...", key)
            # do not add default values - maybe imported pattern
            # ignored them intentionally
            if Ops.get_string(@pattern_descr, [key, "type"], "") == "package-list"
              Ops.set(ret, key, [])
            else
              Ops.set(ret, key, "")
            end
          end
        end
        retlist = Builtins.add(retlist, ret) if ret != {}
      end
      deep_copy(retlist)
    end

    # read the package description (package.lang) file
    def ReadPackagesFile(file_path)
      Builtins.y2milestone("Importing package description '%1'", file_path)

      PackagesDescr.Read(uncompress_file(file_path))
    end

    # import the data from existing add-on
    # @param path to existing addon directory
    def ImportExistingProduct(dir_path)
      @content = ReadContentFile(Ops.add(dir_path, "/content"))

      Ops.set(
        @current_product,
        "rpm_path",
        Builtins.sformat(
          "%1/%2",
          dir_path,
          Ops.get(@content_map, "DATADIR", "")
        )
      )

      # - read patterns
      descr_path = Builtins.sformat(
        "%1/%2",
        dir_path,
        Ops.get(@content_map, "DESCRDIR", "")
      )

      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat(
            "ls -A1 %1/*.pat %1/*.pat.gz 2>/dev/null",
            descr_path
          )
        )
      )
      patterns = {}
      Builtins.foreach(
        Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
      ) do |f|
        next if f == ""
        Builtins.foreach(ReadPatternsFile(f)) do |pat|
          if pat != {}
            full_name = Ops.get_string(pat, "Pat", "")
            pt = Builtins.splitstring(full_name, " ")
            if full_name != ""
              Ops.set(pat, "name", Ops.get(pt, 0, ""))
              Ops.set(pat, "version", Ops.get(pt, 1, ""))
              Ops.set(pat, "release", Ops.get(pt, 2, ""))
              Ops.set(pat, "arch", Ops.get(pt, 3, ""))
              Ops.set(patterns, full_name, pat)
            end
          end
        end
      end
      Ops.set(@current_product, "patterns", patterns)

      if !@generate_descriptions
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat("/bin/rm -f %1/packages*", @tmpdir)
        )
        # save packages* files to tmpdir, they will be imported later
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat("/bin/cp -- '%1/'packages* %2", descr_path, @tmpdir)
        )
      end
      extra = Ops.add(descr_path, "/EXTRA_PROV")
      if FileUtils.Exists(extra)
        cont = Convert.to_string(SCR.Read(path(".target.string"), extra))
        if cont != nil
          Ops.set(@current_product, "extra_prov", cont)
          Ops.set(@current_product, "extra_prov_file", extra)
        end
      end

      # read README
      Builtins.foreach(["README", "README.DOS", "LIESMICH", "LIESMICH.DOS"]) do |readme|
        readme_path = Ops.add(Ops.add(dir_path, "/"), readme)
        if FileUtils.Exists(readme_path)
          Builtins.y2milestone("Importing readme file '%1'", readme_path)
          cont = Convert.to_string(
            SCR.Read(path(".target.string"), readme_path)
          )
          if cont != nil
            Ops.set(@current_product, ["readme_files", readme], cont)
          end
        end
      end

      # read the license files
      license_path = Ops.add(dir_path, "/media.1/license.zip")
      out = {}
      # license.zip is obsolete
      if FileUtils.Exists(license_path)
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat("/usr/bin/unzip -o %1 -d %2", license_path, @tmpdir)
        )
        out = Convert.to_map(
          SCR.Execute(
            path(".target.bash_output"),
            Builtins.sformat("ls -A1 %1/license*.txt 2>/dev/null", @tmpdir)
          )
        )
      elsif FileUtils.Exists(Ops.add(dir_path, "/license.tar.gz"))
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat(
            "/bin/tar -zxf %1/license.tar.gz -C %2",
            dir_path,
            @tmpdir
          )
        )
        out = Convert.to_map(
          SCR.Execute(
            path(".target.bash_output"),
            Builtins.sformat("ls -A1 %1/license*.txt 2>/dev/null", @tmpdir)
          )
        )
      elsif FileUtils.IsDirectory(Ops.add(dir_path, "/media.1/license")) == true
        out = Convert.to_map(
          SCR.Execute(
            path(".target.bash_output"),
            Builtins.sformat(
              "ls -A1 %1/media.1/license/license*.txt 2>/dev/null",
              dir_path
            )
          )
        )
      # extract license.txt from EULA.txt
      # (no other need to read EULA, it should be just license.txt + packages)
      elsif FileUtils.Exists(Ops.add(dir_path, "/EULA.txt"))
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat(
            "/bin/cp -- %1/EULA.txt %2/license.txt",
            dir_path,
            @tmpdir
          )
        )
        out = Convert.to_map(
          SCR.Execute(
            path(".target.bash_output"),
            Builtins.sformat("ls -A1 %1/license*.txt 2>/dev/null", @tmpdir)
          )
        )
      end
      if out != {}
        Builtins.foreach(
          Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
        ) do |f|
          next if f == ""
          name = Builtins.substring(f, Ops.add(Builtins.findlastof(f, "/"), 1))
          if Builtins.issubstring(name, ".txt")
            name = Builtins.regexpsub(name, "^(.*).txt$", "\\1")
          end
          Builtins.y2milestone("Importing license file '%1'", f)
          cont = Convert.to_string(SCR.Read(path(".target.string"), f))
          if cont != nil
            Ops.set(@current_product, ["license_files", name], cont)
          end
        end
      end

      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat("ls -A1 %1/COPYING* 2>/dev/null", dir_path)
        )
      )
      Builtins.foreach(
        Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
      ) do |f|
        next if f == ""
        name = Builtins.substring(f, Ops.add(Builtins.findlastof(f, "/"), 1))
        Builtins.y2milestone("Importing COPYING file '%1'", f)
        cont = Convert.to_string(SCR.Read(path(".target.string"), f))
        Ops.set(@current_product, ["copying_files", name], cont) if cont != nil
      end

      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat("ls -A1 %1/COPYRIGHT* 2>/dev/null", dir_path)
        )
      )
      Builtins.foreach(
        Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
      ) do |f|
        next if f == ""
        name = Builtins.substring(f, Ops.add(Builtins.findlastof(f, "/"), 1))
        Builtins.y2milestone("Importing COPYRIGHT file '%1'", f)
        cont = Convert.to_string(SCR.Read(path(".target.string"), f))
        if cont != nil
          Ops.set(@current_product, ["copyright_files", name], cont)
        end
      end

      # read the info.txt
      info_path = Ops.add(dir_path, "/media.1/info.txt")
      if FileUtils.Exists(info_path)
        info = Convert.to_string(SCR.Read(path(".target.string"), info_path))
        info = "" if info == nil
        Ops.set(@current_product, "info", info)
      end

      # read the content of media.n dirs
      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat("ls -A1 -d %1/media.* 2>/dev/null", dir_path)
        )
      )
      if Ops.get_string(out, "stdout", "") != ""
        products_files = []
        media_files = []
        patches_files = []
        Builtins.foreach(
          Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
        ) do |d|
          next if d == ""
          products_path = Ops.add(d, "/products")
          if FileUtils.Exists(products_path)
            Builtins.y2milestone("Importing products file '%1'", products_path)
            products_files = Builtins.add(
              products_files,
              Convert.to_string(SCR.Read(path(".target.string"), products_path))
            )
          else
            products_files = Builtins.add(products_files, "")
          end
          media_path = Ops.add(d, "/media")
          if FileUtils.Exists(media_path)
            Builtins.y2milestone("Importing media file '%1'", media_path)
            media_files = Builtins.add(
              media_files,
              Convert.to_string(SCR.Read(path(".target.string"), media_path))
            )
          else
            media_files = Builtins.add(media_files, "")
          end
          patches_path = Ops.add(d, "/patches")
          if FileUtils.Exists(patches_path)
            Builtins.y2milestone("Importing patches file '%1'", patches_path)
            patches_files = Builtins.add(
              patches_files,
              Convert.to_string(SCR.Read(path(".target.string"), patches_path))
            )
          else
            patches_files = Builtins.add(patches_files, "")
          end
        end
        Ops.set(@current_product, "products_files", products_files)
        Ops.set(@current_product, "media_files", media_files)
        Ops.set(@current_product, "patches_files", patches_files)
      end

      desc_path = Ops.add(dir_path, "/installation.xml")
      if FileUtils.Exists(desc_path)
        Ops.set(@current_product, "workflow_path", desc_path)
      end

      workflow_packages_path = Ops.add(dir_path, "/y2update.tgz")
      if FileUtils.Exists(workflow_packages_path)
        Ops.set(@current_product, "y2update_path", workflow_packages_path)
      end

      true
    end

    # converts the output of find command (=possibly big string with each file on one line),
    # to the list of smaller strings (<128kB), each with space separated file names
    # @param [String] stdout output of find command
    def create_argument_lists(stdout)
      ret = []
      return deep_copy(ret) if stdout == nil || stdout == ""
      # approximately maximum size of parameters list passed to rpm
      kbytes = 120
      # looks like pre-sorting helps to fasten rpm call
      found = Builtins.sort(Builtins.splitstring(stdout, "\n"))
      if Ops.less_or_equal(Ops.divide(Builtins.size(stdout), 1024), kbytes)
        ret = [Builtins.mergestring(found, " ")]
      else
        line = ""
        Builtins.foreach(found) do |file|
          line = Ops.add(Ops.add(line, file), " ")
          if Ops.greater_than(Ops.divide(Builtins.size(line), 1024), kbytes)
            ret = Builtins.add(ret, line)
            line = ""
          end
        end
        if Ops.less_or_equal(Ops.divide(Builtins.size(line), 1024), kbytes)
          ret = Builtins.add(ret, line)
        end
      end
      deep_copy(ret)
    end

    # this is used during the workflow, not in the write!
    # TODO change name...
    def FillContentDefaults
      # AddOnCreator Build dialog caption
      caption = _("Generating Product Data")

      stages = [
        # Progress stage
        _("Find package directories")
      ]
      steps = [
        # Progress step
        _("Looking for package directories...")
      ]
      if !@clone
        stages = Builtins.union(
          stages,
          [
            # Progress stage
            _("Check package architectures"),
            # Progress stage
            _("Generate content file defaults")
          ]
        )
        steps = Builtins.union(
          steps,
          [
            # Progress step
            _("Checking package architectures..."),
            # Progress step
            _("Generating content file defaults...")
          ]
        )
      end
      stages = Builtins.union(
        stages,
        [
          # Progress stage
          _("Generate package descriptions")
        ]
      )
      steps = Builtins.union(
        steps,
        [
          # Progress step
          _("Generate package descriptions")
        ]
      )

      Progress.New(
        caption,
        " ",
        Builtins.size(stages),
        Convert.convert(stages, :from => "list", :to => "list <string>"),
        Convert.convert(steps, :from => "list", :to => "list <string>"),
        # help text
        _("<b>Wait while generating data for add-on...</b><br/>\n")
      )

      Progress.NextStage
      arch_map = {}
      rpm_path = Ops.get_string(@current_product, "rpm_path", "")

      # 1. find the used architectures
      cmd = Builtins.sformat("cd '%1'; find -maxdepth 1 -type d", rpm_path)
      out = {}
      if rpm_path != ""
        out = Convert.to_map(SCR.Execute(path(".target.bash_output"), cmd))
      end

      @arch_directories = []
      Builtins.foreach(
        Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
      ) do |d|
        splitdir = Builtins.splitstring(d, "/")
        arch_dir = Ops.get_string(splitdir, 1, "")
        if Builtins.contains(@allowed_archs, arch_dir) || arch_dir == "src"
          @arch_directories = Builtins.add(@arch_directories, arch_dir)
        end
      end
      Progress.NextStage

      # name of -release packages, if found
      release_packages = []

      if !@clone
        # 2. get the list of architectures from RPM's
        if rpm_path != ""
          out = Convert.to_map(
            SCR.Execute(
              path(".target.bash_output"),
              Builtins.sformat("find '%1' -name '*.rpm'", rpm_path)
            )
          )
        end
        Builtins.y2milestone("asking the RPM's for ARCH and NAME...")
        # for which architectures are the packages built
        package_architectures = {}
        Builtins.foreach(
          Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
        ) do |f|
          next if f == ""
          out = Convert.to_map(
            SCR.Execute(
              path(".target.bash_output"),
              Builtins.sformat(
                "rpm -q -p '%1' --qf \"%%{ARCH}\n" +
                  "%%{NAME}\n" +
                  "%%|SOURCERPM?{bin}:{src}|\"",
                f
              )
            )
          )
          lines = Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
          arch = Ops.get_string(lines, 0, "")
          name = Ops.get_string(lines, 1, "")
          sourcerpm = Ops.get_string(lines, 2, "")
          # 'arch' is directory where to put final package
          arch = "src" if sourcerpm == "src"
          if name != "" && arch != ""
            Ops.set(
              @available_packages,
              arch,
              Builtins.add(Ops.get(@available_packages, arch, []), name)
            )
            if !Builtins.haskey(@package2filename, arch)
              Ops.set(@package2filename, arch, {})
            end
            if !Builtins.haskey(@srcpackage2filename, arch)
              Ops.set(@srcpackage2filename, arch, {})
            end
            if arch != "src"
              Ops.set(@package2filename, [arch, name], f)
              Ops.set(package_architectures, arch, 1)
            else
              Ops.set(@srcpackage2filename, [arch, name], f)
            end
          end
          if name != "" && Ops.greater_than(Builtins.size(name), 8) &&
              Builtins.issubstring(name, "-release")
            Builtins.y2milestone("release package found: %1, %2", name, f)
            release_packages = Builtins.add(release_packages, f)
          end
        end
        Builtins.y2milestone("... done")
        Progress.NextStage

        # 3. add 'guessed' ARCH.base values to the content file
        if @content_map != {} || arch_map != {}
          @content = [] # new proposal
          Builtins.foreach(@content_descr) do |key, entry|
            if Ops.get(@content_map, key, "") != ""
              Ops.set(entry, "value", Ops.get(@content_map, key, ""))
            end
            if key == "BASEARCHS"
              archs = Builtins.mergestring(@arch_directories, " ")
              if @arch_directories == []
                archs = Builtins.mergestring(
                  Builtins.maplist(package_architectures) { |a, v| a },
                  " "
                )
              end
              Ops.set(entry, "value", archs)
            end
            if key == "DISTRIBUTION" && Ops.get(@content_map, key, "") == ""
              Ops.set(
                entry,
                "value",
                Ops.add(
                  Ops.add(Ops.get(@content_map, "NAME", ""), " "),
                  Ops.get(@content_map, "VERSION", "")
                )
              )
            end
            @content = Builtins.add(@content, entry)
          end
        end
        required_rpm_path = Ops.get_string(
          @current_product,
          "required_rpm_path",
          ""
        )
        # 4. read the list of packages, not present on AddOn
        if required_rpm_path != "" && required_rpm_path != rpm_path
          out = Convert.to_map(
            SCR.Execute(
              path(".target.bash_output"),
              Builtins.sformat("cd '%1'; find -name '*.rpm'", required_rpm_path)
            )
          )
          Builtins.y2milestone("asking the RPM's for NAME...")
          inputs = create_argument_lists(Ops.get_string(out, "stdout", ""))
          output = ""
          Builtins.foreach(inputs) do |input|
            cmd2 = Builtins.sformat(
              "cd '%1'; rpm --qf \"%%{NAME}\n\" -qp %2",
              required_rpm_path,
              input
            )
            out = Convert.to_map(SCR.Execute(path(".target.bash_output"), cmd2))
            output = Ops.add(
              Ops.add(output, Ops.get_string(out, "stdout", "")),
              "\n"
            )
          end
          # remove empty strings and duplicates
          Ops.set(
            @available_packages,
            "ZZZ_required",
            Builtins.toset(Builtins.filter(Builtins.splitstring(output, "\n")) do |name|
              name != ""
            end)
          )
          Builtins.y2milestone("... done")
        end
        Progress.NextStage
      else
        out = Convert.to_map(
          SCR.Execute(
            path(".target.bash_output"),
            Builtins.sformat("find %1 -name '*-release*'", rpm_path)
          )
        )
        Builtins.foreach(
          Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
        ) do |f|
          next if f == ""
          out = Convert.to_map(
            SCR.Execute(
              path(".target.bash_output"),
              Builtins.sformat(
                "rpm -q -p %1 --qf \"%%{NAME}\n%%|SOURCERPM?{bin}:{src}|\"",
                f
              )
            )
          )
          lines = Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
          name = Ops.get_string(lines, 0, "")
          sourcerpm = Ops.get_string(lines, 1, "")
          if sourcerpm != "src" && name != "" &&
              Ops.greater_than(Builtins.size(name), 8) &&
              Builtins.issubstring(name, "-release")
            Builtins.y2milestone("release package found: %1, %2", name, f)
            release_packages = Builtins.add(release_packages, f)
          end
        end
      end
      if rpm_path == ""
        Progress.Finish
        return
      end
      reldir = Ops.add(@tmpdir, "/release")
      if release_packages != []
        # when release package is present, do not offer to change it
        Ops.set(@current_product, "generate_release_package", false)
      end
      requireslist = []

      # read the product info contained in release package
      Builtins.foreach(release_packages) do |release_package|
        # use 'reldir' only for one package
        SCR.Execute(path(".target.bash"), Ops.add("rm -rf ", reldir))
        SCR.Execute(path(".target.mkdir"), reldir)
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat("cp -- %1 %2", release_package, reldir)
        )
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat(
            "cd %1; rpm2cpio %2 | cpio -imud 2>/dev/null",
            reldir,
            Builtins.substring(
              release_package,
              Ops.add(Builtins.findlastof(release_package, "/"), 1)
            )
          )
        )
        out = Convert.to_map(
          SCR.Execute(
            path(".target.bash_output"),
            Builtins.sformat(
              "ls -A1 %1/release/etc/products.d/*.prod 2>/dev/null",
              @tmpdir
            )
          )
        )
        out_l = Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
        prod_file = Ops.get_string(out_l, 0, "") # we care about the first one
        if prod_file == ""
          # release package does not contain .prod, it may be flavor package:
          # check for product dependencies
          # rpm -qp --requires `path to rpm` | grep product
          out = Convert.to_map(
            SCR.Execute(
              path(".target.bash_output"),
              Builtins.sformat(
                "rpm -qp --requires %1 | grep \"product(.*)\"",
                release_package
              )
            )
          )
          # line is e.g. 'product(SUSE_SLED-SP3-dvd5) = 11-2', which means
          # name-SPpatchlevel-flavor flag version-release, where
          # only name, flag and version are mandatory
          re = "^product[(]+([^-]*)[-]*(SP[0-9]*)*[-]*([^-]*)[)]+[ \t]*([<=>]+)[ \t]*([0-9]*)[-]*(.*)$"
          Builtins.foreach(
            Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
          ) do |prodline|
            next if prodline == ""
            tokens = Builtins.regexptokenize(prodline, re)
            # = ["SUSE_SLED","SP3","dvd5","=","11","2"] for above example
            flag = "EQ"
            if Ops.get_string(tokens, 3, "") == ">"
              flag = "GE"
            elsif Ops.get_string(tokens, 3, "") == "<"
              flag = "LT"
            end
            requiremap = {
              "name"    => Ops.get_string(tokens, 0, ""),
              "version" => Ops.get_string(tokens, 4, ""),
              "flag"    => flag
            }
            if Ops.get_string(tokens, 1, "") != ""
              Ops.set(
                requiremap,
                "patchlevel",
                Builtins.substring(Ops.get_string(tokens, 1, ""), 2)
              )
            end
            if Ops.get_string(tokens, 2, "") != ""
              Ops.set(requiremap, "flavor", Ops.get_string(tokens, 2, ""))
            end
            if Ops.get_string(tokens, 5, "") != ""
              Ops.set(requiremap, "release", Ops.get_string(tokens, 5, ""))
            end
            Builtins.y2milestone("requiremap: %1", requiremap)
            requireslist = Builtins.add(requireslist, requiremap)
          end
          next
        end
        Builtins.y2milestone("reading product info from %1", prod_file)
        # read the prod file info and add it into the template
        @product_xml = ReadProductXML(prod_file)
        # translate product_xml map into product_info
        @product_info = GetProductInfo(@product_xml, true)
      end
      if requireslist != []
        Ops.set(
          @product_info,
          "requires",
          Ops.get(@product_info_descr, "requires", {})
        )
        Ops.set(@product_info, ["requires", "value"], requireslist)
      end

      # generate tmp package descriptions...
      if (@generate_descriptions || !@clone) &&
          FileUtils.Exists("/usr/bin/create_package_descr")
        Builtins.y2milestone("creating packages descriptions...")
        cmd = Builtins.sformat(
          "/usr/bin/create_package_descr -d '%1' -C -F -o %2",
          rpm_path,
          @tmpdir
        )
        SCR.Execute(path(".target.bash"), cmd, { "LANG" => "C" })
        Builtins.y2milestone("... done")
      end
      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat("ls -A1 %1/packages.* 2>/dev/null", @tmpdir)
        )
      )
      lang = "en"
      packages_descr = Ops.get_map(@current_product, "packages_descr", {})
      Builtins.foreach(
        Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
      ) do |file|
        f = Builtins.splitstring(file, ".")
        lang = Ops.get_string(f, Ops.subtract(Builtins.size(f), 1), "en")
        if lang == "gz" # fortunatelly, there is no 'gz' locale...
          if Ops.greater_than(Builtins.size(f), 2)
            lang = Ops.get_string(f, Ops.subtract(Builtins.size(f), 2), "en")
          else
            next
          end
        end
        next if file == "" || lang == "DU" || lang == "FL"
        if Ops.get_map(packages_descr, lang, {}) == {}
          Ops.set(packages_descr, lang, ReadPackagesFile(file))
          next
        end
        package_names = Builtins.mapmap(Ops.get_map(packages_descr, lang, {})) do |p, d|
          { Ops.get(Builtins.splitstring(p, " "), 0, p) => p }
        end
        # now, we need to merge old data from packages_descr with currently
        # generated ones (TODO this works only for packages.en)
        Builtins.foreach(
          Convert.convert(
            ReadPackagesFile(file),
            :from => "map",
            :to   => "map <string, map>"
          )
        ) do |p, d|
          if !Builtins.haskey(Ops.get_map(packages_descr, lang, {}), p)
            Builtins.y2debug("new package %1", d)
            Ops.set(packages_descr, [lang, p], d)
            name = Ops.get(Builtins.splitstring(p, " "), 0, p)
            if Ops.get_string(package_names, name, "") != ""
              Builtins.y2milestone(
                "replacing saved '%1' with present '%2'",
                Ops.get_string(package_names, name, ""),
                p
              )
              Ops.set(
                packages_descr,
                lang,
                Builtins.remove(
                  Ops.get_map(packages_descr, lang, {}),
                  Ops.get_string(package_names, name, "")
                )
              )
            end
          end
        end
      end
      Ops.set(@current_product, "packages_descr", packages_descr)

      # we need the list of packages (for patterns), but asking
      # rpm would be slow, so let's get it from (already existing) descriptions
      if @clone
        Builtins.y2milestone(
          "gathering available_packages from descriptions..."
        )
        Builtins.foreach(Ops.get_map(packages_descr, lang, {})) do |p, d|
          next if p == "___global___"
          pkg_list = Builtins.splitstring(Ops.get_string(d, "Pkg", ""), " ")
          arch = Ops.get_string(
            pkg_list,
            Ops.subtract(Builtins.size(pkg_list), 1),
            "noarch"
          )
          Ops.set(
            @available_packages,
            arch,
            Builtins.add(Ops.get(@available_packages, arch, []), p)
          )
        end
      end
      Progress.NextStage

      nil
    end

    # Write the content file
    # @return success
    def WriteContentFile(base_path, content_data)
      content_data = deep_copy(content_data)
      return false if !FileUtils.Exists(base_path)

      file = ""
      Builtins.foreach(content_data) do |entry|
        if Ops.get_string(entry, "value", "") != ""
          if Ops.get_string(entry, "key", "") != "CONTENTSTYLE"
            file = Ops.add(
              file,
              Builtins.sformat(
                "%1 %2\n",
                Ops.get_string(entry, "key", ""),
                Ops.get_string(entry, "value", "")
              )
            )
          end
          Ops.set(
            @content_map,
            Ops.get_string(entry, "key", ""),
            Ops.get_string(entry, "value", "")
          )
        end
      end
      # CONTENTSTYLE must be first key...
      file = Ops.add(
        Builtins.sformat(
          "CONTENTSTYLE %1\n",
          Ops.get(@content_map, "CONTENTSTYLE", "11")
        ),
        file
      )

      SCR.Write(path(".target.string"), Ops.add(base_path, "/content"), file)
    end

    # Write the readme/COPYING/COPYRIGHT... files in base_path
    # @return success
    def WriteStringFiles(base_path, files)
      files = deep_copy(files)
      return false if !FileUtils.Exists(base_path)

      ret = true
      Builtins.foreach(files) do |file, cont|
        if cont != ""
          ret = ret &&
            SCR.Write(
              path(".target.string"),
              Ops.add(Ops.add(base_path, "/"), file),
              cont
            )
        end
      end
      ret
    end

    # generate the paths of media, data and description dirs
    def GenerateDirectories(base_path)
      i = 1
      no_of_medias = 1
      while Ops.less_or_equal(i, no_of_medias)
        media_path = Builtins.sformat("%1/media.%2", base_path, i)
        @full_media_paths = Builtins.add(@full_media_paths, media_path)
        i = Ops.add(i, 1)
      end
      @full_data_path = Builtins.sformat(
        "%1/%2",
        base_path,
        Ops.get(@content_map, "DATADIR", "")
      )
      @full_descr_path = Builtins.sformat(
        "%1/%2",
        base_path,
        Ops.get(@content_map, "DESCRDIR", "")
      )

      nil
    end

    # Create the directory structure of the Add-On
    # @return success
    def CreateAddOnStructure(base_path)
      return false if !FileUtils.Exists(base_path)

      GenerateDirectories(base_path)
      # create the media's directories
      Builtins.foreach(@full_media_paths) do |dir|
        SCR.Execute(path(".target.mkdir"), dir)
      end

      # create the data dir
      if Ops.get(@content_map, "DATADIR", "") == ""
        Builtins.y2error(
          "DATADIR is : %1",
          Ops.get(@content_map, "DATADIR", "")
        )
        return false
      end

      SCR.Execute(path(".target.mkdir"), @full_data_path)

      # create the dirs for packages
      Builtins.foreach(@available_packages) do |arch_dir, pa|
        if arch_dir != "ZZZ_imported" && arch_dir != "ZZZ_required"
          SCR.Execute(
            path(".target.mkdir"),
            Ops.add(Ops.add(@full_data_path, "/"), arch_dir)
          )
        end
      end if @arch_directories == []

      SCR.Execute(path(".target.mkdir"), @full_descr_path)

      true
    end

    # Generate the package descriptions using create_package_descr
    def GeneratePackageDescriptions
      return false if !FileUtils.Exists("/usr/bin/create_package_descr")

      command = Builtins.sformat(
        "/usr/bin/create_package_descr -d %1 -C -F -o %2",
        @full_data_path,
        @full_descr_path
      )
      SCR.Execute(path(".target.bash_output"), command, { "LANG" => "C" })
      true
    end

    # Write the package descriptions edited by user
    # @path descr_path full path to directory with package descriptions (DESCRDIR)
    # @path map with package descriptions
    def WritePackageDescriptions(descr_path, descr)
      descr = deep_copy(descr)
      return false if !FileUtils.Exists(descr_path)

      Builtins.y2milestone("writing package description files...")

      ret = true
      return ret if descr == {}
      Builtins.foreach(
        Convert.convert(descr, :from => "map", :to => "map <string, map>")
      ) do |lang, data|
        file_path = Ops.add(Ops.add(descr_path, "/packages."), lang)
        ret = ret &&
          PackagesDescr.Write(
            file_path,
            Convert.convert(data, :from => "map", :to => "map <string, any>")
          )
        Builtins.y2debug("file '%1' written, retval: %2", file_path, ret)
        if @compress_package_descriptions && gzip_installed
          Builtins.y2debug(
            "compressing %1 file: %2",
            file_path,
            SCR.Execute(
              path(".target.bash"),
              Builtins.sformat("gzip %1", file_path)
            )
          )
        end
      end
      if ret # copy the rest of files, generated earlier
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat(
            "/bin/rm -f '%1/packages' '%1/packages.DU*' '%1/packages.FL*'",
            descr_path
          )
        )
        Builtins.foreach(["packages", "packages.DU", "packages.FL"]) do |file|
          pth = Ops.add(Ops.add(@tmpdir, "/"), file)
          Builtins.y2debug("processing '%1'", pth)
          compress = false
          if !FileUtils.Exists(pth) && FileUtils.Exists(Ops.add(pth, ".gz"))
            pth = Ops.add(pth, ".gz")
          elsif @compress_package_descriptions
            compress = true
          end
          cmd = Builtins.sformat("/bin/cp -- %1 '%2'", pth, descr_path)
          SCR.Execute(path(".target.bash"), cmd, { "LANG" => "C" })
          if compress
            SCR.Execute(
              path(".target.bash"),
              Builtins.sformat("gzip %1/%2", descr_path, file)
            )
          end
        end
      end

      extra_prov = Ops.get_string(@current_product, "extra_prov", "")
      if extra_prov != "" && extra_prov != nil
        SCR.Write(
          path(".target.string"),
          Ops.add(descr_path, "/EXTRA_PROV"),
          extra_prov
        )
      end

      Builtins.y2milestone("... done")
      ret
    end

    # Generate ARCHIVES.gz, INDEX.gz and ls-lR.gz
    # @param [String] base_path path to base output directory
    def GenerateArchiveFiles(base_path)
      if !Package.Installed("inst-source-utils") &&
          !FileUtils.Exists("/usr/bin/mk_listings")
        Builtins.y2error(
          "inst-source-utils not installed and mk_listings not present"
        )
        return false
      end
      return false if !FileUtils.Exists(base_path)

      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat("cd '%1';mk_listings .", base_path)
        )
      )
      if Ops.get_string(out, "stderr", "") != ""
        Builtins.y2warning("mk_listings returns %1", out)
      end
      true
    end


    # Create the patches files
    # @param [String] base_path path to base output directory
    # @param list with patches file contents
    # @return success
    def WritePatchesFiles(base_path, p_files)
      p_files = deep_copy(p_files)
      return false if !FileUtils.Exists(base_path)

      i = 1
      Builtins.foreach(p_files) do |cont|
        file_path = Ops.add(base_path, Builtins.sformat("/media.%1/patches", i))
        SCR.Write(path(".target.string"), file_path, cont) if cont != ""
        i = Ops.add(i, 1)
      end
      true
    end
    # Create the products file TODO editor - see ExpertSettingsDialog3
    # @param [String] base_path path to base output directory
    # @return success
    def WriteProductsFiles(base_path, p_files)
      p_files = deep_copy(p_files)
      return false if !FileUtils.Exists(base_path)

      i = 1
      p_files = [""] if p_files == []
      Builtins.foreach(p_files) do |cont|
        if cont == ""
          cont = Ops.add(
            Ops.add(Ops.add("/\t", Ops.get(@content_map, "NAME", "")), " "),
            Ops.get(@content_map, "VERSION", "")
          )
        end
        SCR.Write(
          path(".target.string"),
          Builtins.sformat("%1/media.%2/products", base_path, i),
          cont
        )
        i = Ops.add(i, 1)
      end
      true
    end

    # Write the media.n/media files
    # @param [String] base_path path to base output directory
    # @param [Array<String>] m_files list of media files contents
    # @param [String] next content of nextmedia file
    # @return success
    def WriteMediaFiles(base_path, m_files, _next)
      m_files = deep_copy(m_files)
      return false if !FileUtils.Exists(base_path)

      i = 1
      m_files = [""] if m_files == []
      Builtins.foreach(m_files) do |cont|
        media_path = Ops.add(base_path, Builtins.sformat("/media.%1", i))
        if cont == ""
          media_id = ""
          out = Convert.to_map(
            SCR.Execute(path(".target.bash_output"), "date +%Y%m%d%H%M%S")
          )
          media_id = Builtins.deletechars(
            Ops.get_string(out, "stdout", ""),
            "\n"
          )
          cont = Ops.add(
            Ops.add(Ops.get(@content_map, "VENDOR", ""), "\n"),
            media_id
          )
          cont = Ops.add(Ops.add(cont, "\n"), Builtins.size(m_files)) if i == 1
        end
        SCR.Write(path(".target.string"), Ops.add(media_path, "/media"), cont)
        # write nextmedia file if not empty
        if i == 1 && _next != ""
          SCR.Write(
            path(".target.string"),
            Ops.add(media_path, "/nextmedia"),
            _next
          )
        end
        i = Ops.add(i, 1)
      end
      true
    end

    # write info.txt file
    def WriteInfoFile(info_dir, info)
      if info != "" && info != nil
        SCR.Write(path(".target.string"), Ops.add(info_dir, "/info.txt"), info)
      end
      true
    end


    # Write the text of available licenses to correct places
    # @path descr_path full path to directory with package descriptions (DESCRDIR)
    # @param [String] base_path full path to base output directory
    # @patram files map of license files and their contents ($[ name : content ])
    def WriteLicensesFiles(descr_path, base_path, files)
      files = deep_copy(files)
      if !FileUtils.Exists(base_path)
        Builtins.y2warning("no %1 directory exists...", base_path)
        return false
      end
      Builtins.y2milestone("writing licenses...")
      ret = true
      cmd = ""
      Builtins.foreach(files) do |file, cont|
        if cont != ""
          pos = Builtins.findlastof(file, ".")
          if pos == nil || Builtins.substring(file, pos) != ".txt"
            file = Ops.add(file, ".txt")
          end
          cmd = Ops.add(Ops.add(cmd, " "), file)
          ret = ret &&
            SCR.Write(
              path(".target.string"),
              Ops.add(Ops.add(@tmpdir, "/"), file),
              cont
            )
          if file == "license.txt"
            SCR.Write(
              path(".target.string"),
              Ops.add(@tmpdir, "/EULA.txt"),
              cont
            )
          end
        end
      end
      # tar + gzip the licenses into one file
      if ret && cmd != ""
        cmd = Builtins.sformat(
          "cd %1; tar -czf %2/license.tar.gz license*.txt",
          @tmpdir,
          base_path
        )
        out = Convert.to_map(SCR.Execute(path(".target.bash_output"), cmd))
        if Ops.get_string(out, "stderr", "") != ""
          Builtins.y2warning("%1 returned %2", cmd, out)
          ret = false
        end
      end
      # merge the license of packages into EULA.txt
      if !FileUtils.Exists(Ops.add(@tmpdir, "/EULA.txt"))
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat("touch %1/EULA.txt", @tmpdir)
        )
      end
      if FileUtils.Exists("/usr/bin/packages2eula.pl")
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat(
            "/usr/bin/packages2eula.pl -p %1/packages.en -o %2/EULA.txt 2>/dev/null",
            descr_path,
            @tmpdir
          )
        )
      end
      if Ops.greater_than(FileUtils.GetSize(Ops.add(@tmpdir, "/EULA.txt")), 0)
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat("cp -- %1/EULA.txt %2/", @tmpdir, base_path)
        )
      end

      ret
    end

    # Write all files with patterns definitions
    # @path descr_path full path to directory with package descriptions (DESCRDIR)
    # @param [String] base_path path to base output directory
    def WritePatterns(descr_path, base_path)
      if !FileUtils.Exists(base_path) || !FileUtils.Exists(descr_path)
        Builtins.y2warning(
          "%1 or %2 directory not available...",
          base_path,
          descr_path
        )
        return false
      end

      ret = true
      names = []
      Builtins.foreach(Ops.get_map(@current_product, "patterns", {})) do |full_name, pattern|
        filename = CreatePatternFullName(pattern, true)
        next if filename == ""
        names = Builtins.add(names, filename)
        file = Builtins.sformat(
          "=Ver: %1\n\n=Pat: %2\n",
          Ops.get_string(
            pattern,
            "Ver",
            Ops.get_string(@pattern_descr, ["Ver", "defval"], "")
          ),
          Ops.get_string(pattern, "Pat", "")
        )
        pattern = Builtins.remove(Builtins.remove(pattern, "Ver"), "Pat")
        Builtins.foreach(
          Convert.convert(pattern, :from => "map", :to => "map <string, any>")
        ) do |key, val|
          descr = Ops.get(@pattern_descr, key, {})
          # substring (key,0,3) is because of Des.lang, Sum.lang and Cat.lang
          shortkey = Builtins.substring(key, 0, 3)
          if Ops.get(@pattern_descr, shortkey, {}) != {} &&
              Builtins.substring(key, 3, 1) == "."
            descr = Ops.get(@pattern_descr, shortkey, {})
          end
          if val == nil || val == "" || val == [] ||
              Ops.get_boolean(descr, "internal", false)
            next
          end
          file = Ops.add(file, "\n") if file != ""
          if Ops.get_string(descr, "type", "") == "boolean"
            val = Convert.to_boolean(val) ? "true" : "false"
          elsif Ops.get_string(descr, "type", "") == "package-list"
            val = Builtins.mergestring(
              Convert.convert(val, :from => "any", :to => "list <string>"),
              "\n"
            )
          end
          if Ops.get_boolean(descr, "single_line", false)
            file = Ops.add(file, Builtins.sformat("=%1: %2\n", key, val))
          else
            file = Ops.add(file, Builtins.sformat("+%1:\n%2\n-%1:\n", key, val))
          end
        end
        Builtins.y2milestone(
          "writing pattern %1/%2: %3",
          descr_path,
          filename,
          SCR.Write(
            path(".target.string"),
            Ops.add(Ops.add(descr_path, "/"), filename),
            file
          )
        )
        if @compress_patterns && gzip_installed
          Builtins.y2debug(
            "compressing pattern file: %1",
            SCR.Execute(
              path(".target.bash"),
              Builtins.sformat("gzip %1/%2", descr_path, filename)
            )
          )
        end
      end
      if names != []
        ret = SCR.Write(
          path(".target.string"),
          Ops.add(descr_path, "/patterns"),
          Builtins.mergestring(names, "\n")
        )
      end
      ret
    end

    # Copy the packages from the source directory to target
    # @param [String] in_path source path
    # @param [String] base_path destination directory
    # @return success
    def CopyRPMs(in_path, base_path)
      return true if in_path == ""

      return false if !FileUtils.Exists(base_path) || !FileUtils.Exists(in_path)
      # packages in the directories with arch name
      if @arch_directories != []
        Builtins.foreach(@arch_directories) do |arch|
          dir = Ops.add(Ops.add(in_path, "/"), arch)
          if FileUtils.Exists(dir)
            Builtins.y2milestone(
              "copying from %1 to %2...",
              dir,
              @full_data_path
            )
            SCR.Execute(
              path(".target.bash_output"),
              Builtins.sformat("/bin/cp -r -- '%1' '%2/'", dir, @full_data_path)
            )
          end
        end
      # packages not in directories but we have asked them for arch's
      elsif @available_packages != {}
        Builtins.foreach(@available_packages) do |arch, pa|
          out_dir = Ops.add(Ops.add(@full_data_path, "/"), arch)
          if arch != "ZZZ_imported" && arch != "ZZZ_required" &&
              FileUtils.Exists(out_dir)
            Builtins.y2milestone("copying packages of '%1' architecture", arch)
            # arch_directories will be needed later for CreateMD5SUMS and
            # resign_packages
            @arch_directories = Convert.convert(
              Builtins.union(@arch_directories, [arch]),
              :from => "list",
              :to   => "list <string>"
            )
            if Ops.greater_than(Builtins.size(@package2filename), 0) &&
                arch != "src"
              Builtins.y2debug("package names known")
              Builtins.foreach(
                Convert.convert(pa, :from => "list", :to => "list <string>")
              ) do |p|
                SCR.Execute(
                  path(".target.bash"),
                  Builtins.sformat(
                    "/bin/cp -- '%1' '%2/'",
                    Ops.get_string(@package2filename, [arch, p], ""),
                    out_dir
                  )
                )
              end
            elsif Ops.greater_than(Builtins.size(@srcpackage2filename), 0) &&
                arch == "src"
              Builtins.y2debug("source packages, names known")
              Builtins.foreach(
                Convert.convert(pa, :from => "list", :to => "list <string>")
              ) do |p|
                SCR.Execute(
                  path(".target.bash"),
                  Builtins.sformat(
                    "/bin/cp -- '%1' '%2/'",
                    Ops.get_string(@srcpackage2filename, [arch, p], ""),
                    out_dir
                  )
                )
              end
            else
              Builtins.y2debug("package names not known, using wildcard")
              Builtins.foreach(
                Convert.convert(pa, :from => "list", :to => "list <string>")
              ) do |p|
                SCR.Execute(
                  path(".target.bash"),
                  Builtins.sformat(
                    "/bin/cp -- '%1/%2'*.rpm '%3/'",
                    in_path,
                    p,
                    out_dir
                  )
                )
              end
            end
          end
        end
      end
      true
    end


    # Use BuildService tools to create -release package with product info
    def GenerateReleasePackage(base_path)
      if !Ops.get_boolean(@current_product, "generate_release_package", false)
        Builtins.y2milestone("release package should not be generated")
        return true
      end
      if !Package.Install("obs-productconverter")
        # error report
        Report.Error(
          _(
            "Failed to install obs-productconverter package.\nRelease package will not be generated."
          )
        )
        return false
      end
      if !FileUtils.Exists(@full_data_path)
        Builtins.y2error("path '%1' does not exist", @full_data_path)
        return false
      end
      # release packages names and architectures
      release_packages = {}

      # 1. update product_xml map using product_info and content,
      # write the result into temporary .prod file
      name = Ops.get(@content_map, "NAME", "add-on")

      submap = deep_copy(@product_xml)
      if Ops.greater_than(
          Builtins.size(
            Ops.get_list(@product_xml, ["productdefinition", 0, "products"], [])
          ),
          0
        )
        submap = Ops.get_map(
          @product_xml,
          ["productdefinition", 0, "products", 0],
          {}
        )
      end
      submap = Ops.get_map(submap, ["product", 0], {})

      Ops.set(submap, "id", name)
      Ops.set(submap, ["name", 0, @content_key], name)
      Ops.set(
        submap,
        ["version", 0, @content_key],
        Ops.get(@content_map, "VERSION", "1.0")
      )
      Ops.set(
        submap,
        ["vendor", 0, @content_key],
        Ops.get(@content_map, "VENDOR", "")
      )

      Builtins.foreach(["release", "summary", "description"]) do |key|
        if Ops.get_string(@product_info, [key, "value"], "") == ""
          Ops.set(@product_info, [key, "value"], key == "release" ? "0" : name)
        end
        Ops.set(
          submap,
          [key, 0, @content_key],
          Ops.get_string(@product_info, [key, "value"], "")
        )
      end

      if Ops.get_string(@product_info, ["releasenotes", "value"], "") != ""
        i = -1
        Builtins.foreach(Ops.get_list(submap, ["urls", 0, "url"], [])) do |url|
          i = Ops.add(i, 1)
          if Ops.get_string(url, "name", "") == "releasenotes"
            Ops.set(
              submap,
              ["urls", 0, "url", i, @content_key],
              Ops.get_string(@product_info, ["releasenotes", "value"], "")
            )
          end
        end
        if i == -1
          Ops.set(
            submap,
            "urls",
            [
              {
                "url" => [
                  {
                    "name"       => "releasenotes",
                    @content_key => Ops.get_string(
                      @product_info,
                      ["releasenotes", "value"],
                      ""
                    )
                  }
                ]
              }
            ]
          )
        end
      end
      # write the dependency stuff
      dependency = []
      Builtins.foreach(@product_info) do |key, desc|
        if Ops.get_string(desc, "type", "") == "dependency"
          Builtins.foreach(Ops.get_list(desc, "value", [])) do |dep|
            dependency = Builtins.add(
              dependency,
              Builtins.add(dep, "relationship", key)
            )
          end
        end
      end
      mediasets = []
      if Ops.greater_than(Builtins.size(dependency), 0)
        mediasets = [
          {
            "media" => [
              {
                "productdependency" => dependency,
                "type"              => Ops.get_string(
                  @product_info,
                  ["media type", "value"],
                  "dvd"
                ),
                "flavor"            => Ops.get_string(
                  @product_info,
                  ["flavor", "value"],
                  "dvd"
                ),
                "name"              => name,
                "product"           => name
              }
            ]
          }
        ]
      end

      @product_xml = {
        "productdefinition" => [
          {
            "products"  => [{ "product" => [submap] }],
            "mediasets" => mediasets
          }
        ]
      }

      prod_file_path = Builtins.sformat("%1/%2.product", @tmpdir, name)

      SCR.Write(
        path(".anyxml"),
        {
          "file" => prod_file_path,
          "xml"  => @product_xml,
          "args" => {
            "XMLDecl"      => "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "ForceContent" => 1,
            "ForceArray"   => 1,
            "KeepRoot"     => 1,
            "ContentKey"   => @content_key,
            "KeyAttr"      => []
          }
        }
      )
      product_dir = Ops.add(Ops.add(@tmpdir, "/"), name)
      SCR.Execute(path(".target.mkdir"), product_dir)

      # 2. call bs_productconvert to generate a spec file for -release package
      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat(
            "/usr/lib/obs/server/bs_productconvert %1 %2 %3",
            prod_file_path,
            product_dir,
            name
          )
        )
      )
      if Ops.get_integer(out, "exit", 0) != 0
        Builtins.y2error(
          "bs_productconvert failed with %1",
          Ops.get_string(out, "stderr", "")
        )
        SCR.Execute(path(".target.remove"), prod_file_path)
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat("rm -rf '%1'", product_dir)
        )
        return false
      end

      # 3. build the release package from generated .spec file
      cmd = Builtins.sformat(
        "rpmbuild -bb `find -L %1 -name %2-release.spec`",
        @tmpdir,
        name
      )
      out = Convert.to_map(
        SCR.Execute(path(".target.bash_output"), cmd, { "LANG" => "C" })
      )
      if Ops.get_integer(out, "exit", 0) != 0
        # error popup
        Report.Error(
          Builtins.sformat(
            _("Build of release package failed with\n'%1'."),
            Ops.get_string(out, "stderr", "")
          )
        )
        Builtins.y2error("command '%1' failed with: \n%2", cmd, out)
      else
        Builtins.foreach(
          Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
        ) do |line|
          if Ops.greater_than(Builtins.size(line), 8) &&
              Builtins.substring(line, 0, 7) == "Wrote: "
            ll = Builtins.splitstring(line, " \t\n")
            package = Ops.get_string(ll, 1, "")
            if package != "" && FileUtils.Exists(package)
              Builtins.y2milestone("release package: %1", package)
              out = Convert.to_map(
                SCR.Execute(
                  path(".target.bash_output"),
                  Builtins.sformat("rpm -q -p %1 --qf \"%%{ARCH}\"", package)
                )
              )
              Ops.set(
                release_packages,
                package,
                Ops.get_string(out, "stdout", "")
              )
            end
          end
        end
      end
      # 4. copy the release package to the correct place
      Builtins.foreach(release_packages) do |package_path, arch|
        # create arch directory if it does not exist
        if !Builtins.contains(@arch_directories, arch)
          @arch_directories = Builtins.add(@arch_directories, arch)
          SCR.Execute(
            path(".target.mkdir"),
            Ops.add(Ops.add(@full_data_path, "/"), arch)
          )
        end
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat(
            "/bin/cp -r -- %1 '%2/%3'",
            package_path,
            @full_data_path,
            arch
          )
        )
      end
      # 5. generate metadata for new package
      Builtins.y2milestone(
        "updating packages descriptions after adding release packages"
      )
      cmd = Builtins.sformat(
        "/usr/bin/create_package_descr -d %1 -C -F -o %2",
        @full_data_path,
        @tmpdir
      )
      if SCR.Execute(path(".target.bash"), cmd, { "LANG" => "C" }) != 0
        Builtins.y2error("'%1' failed", cmd)
      end
      # 6. delete the tmp files, so it doesn't mess possible next builds
      SCR.Execute(path(".target.remove"), prod_file_path)
      SCR.Execute(
        path(".target.bash"),
        Builtins.sformat("rm -rf '%1'", product_dir)
      )
      true
    end



    # Write the modification of installation workflow
    # @param [String] base_path path to base output directory
    # @param [String] desc_path path to workflow description file
    # @param [Array<String>] packages list with paths of packages to be included in y2update.tgz
    # @param y2update path to existing y2update.tgz
    def WriteWorkflow(base_path, desc_path, packages, y2update_p)
      packages = deep_copy(packages)
      return false if !FileUtils.Exists(base_path)

      ret = true
      if desc_path != "" && FileUtils.Exists(desc_path)
        Builtins.y2milestone(
          "writing %1 as %2/installation.xml",
          desc_path,
          base_path
        )
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat(
            "cp -- '%1' '%2/installation.xml'",
            desc_path,
            base_path
          )
        )
      end
      if y2update_p != ""
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat(
            "cp -- '%1' '%2/y2update.tgz'",
            y2update_p,
            base_path
          )
        )
      elsif packages != []
        y2update_dir = Ops.add(@tmpdir, "/y2update")
        SCR.Execute(path(".target.mkdir"), y2update_dir)
        Builtins.foreach(packages) do |p|
          Builtins.y2milestone("extracting %1", p)
          cmd2 = Builtins.sformat(
            "cd '%1'; rpm2cpio %2 | cpio -imud 2>&1",
            y2update_dir,
            p
          )
          Builtins.y2debug("extracting rpm: %1", cmd2)
          out2 = Convert.to_map(SCR.Execute(path(".target.bash_output"), cmd2))
          if Ops.get_string(out2, "stderr", "") != ""
            Builtins.y2warning("%1 returned %2", cmd2, out2)
          end
        end
        cmd = Builtins.sformat(
          "cd '%2'; tar -czf '%1/y2update.tgz' .",
          base_path,
          y2update_dir
        )
        Builtins.y2debug("tar cmd: %1", cmd)
        out = Convert.to_map(SCR.Execute(path(".target.bash_output"), cmd))
        if Ops.get_string(out, "stderr", "") != ""
          Builtins.y2warning("%1 returned %2", cmd, out)
          ret = false
        end
      end
      ret
    end

    # Generate Changelog for the product
    # @param [String] base_path base output path
    def GenerateChangelog(base_path)
      if !Package.Installed("inst-source-utils") &&
          !FileUtils.Exists("/usr/bin/mk_changelog")
        Builtins.y2error(
          "inst-source-utils not installed and mk_changelog not present"
        )
        return false
      end
      return false if !FileUtils.Exists(base_path)

      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat("cd '%1'; mk_changelog", base_path),
          { "ROOT_ON_CD" => Ops.get(@content_map, "DATADIR", "") }
        )
      )
      if Ops.get_string(out, "stderr", "") != ""
        Builtins.y2warning("mk_changelog returns %1", out)
      end
      true
    end

    # Generate servicepack.tar.gz archive for bootable media
    # @param [String] base_path base output path
    def WriteServicepackArchive(base_path)
      return false if !FileUtils.Exists(base_path)

      ret = true
      return ret if !@bootable

      spdir = Ops.add(@tmpdir, "/servicepack")
      SCR.Execute(path(".target.mkdir"), spdir)

      SCR.Execute(
        path(".target.bash"),
        Builtins.sformat("cp -- '%1/content'* %2/", base_path, spdir)
      )

      SCR.Execute(
        path(".target.bash"),
        Builtins.sformat("cp -- '%1/gpg-pubkey'* %2/", base_path, spdir)
      )

      SCR.Execute(
        path(".target.bash"),
        Builtins.sformat("cp -r -- '%1/media.1' %2/", base_path, spdir)
      )

      # copy descriptions (with the stucture)
      descr_path = Builtins.sformat(
        "%1/%2",
        spdir,
        Ops.get(@content_map, "DESCRDIR", "")
      )
      SCR.Execute(path(".target.mkdir"), descr_path)
      SCR.Execute(
        path(".target.bash"),
        Builtins.sformat("cp -- '%1/'* '%2/'", @full_descr_path, descr_path)
      )

      if Ops.get_string(@current_product, "workflow_path", "") != ""
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat(
            "cp -- '%1/installation.xml' '%2/'",
            base_path,
            spdir
          )
        )
      end

      if FileUtils.Exists(Ops.add(base_path, "/y2update.tgz"))
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat("cp -- '%1/y2update.tgz' '%2'", base_path, spdir)
        )
      end

      # finally, create the archive
      cmd = Builtins.sformat(
        "cd '%1'; tar -czf '%2/servicepack.tar.gz' .",
        spdir,
        base_path
      )
      Builtins.y2debug("tar cmd: %1", cmd)
      out = Convert.to_map(SCR.Execute(path(".target.bash_output"), cmd))
      if Ops.get_string(out, "stderr", "") != ""
        Builtins.y2warning("%1 returned %2", cmd, out)
        ret = false
      end
      ret
    end

    # helper to check if directory contains any files (-type f)
    def dir_has_files(dir)
      return false if !FileUtils.Exists(dir)

      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat("cd '%1'; find -maxdepth 1 -type f | wc -l", dir)
        )
      )
      count = Builtins.tointeger(
        Builtins.deletechars(Ops.get_string(out, "stdout", "0"), "\n")
      )
      count != nil && Ops.greater_than(count, 0)
    end

    # Create MD5SUMS files
    # @return success
    def CreateMD5SUMS(base_path)
      return false if !FileUtils.Exists(base_path)

      # after CopyRPMs, arch_directories contains list of directories with RPM's
      dirs_for_md5 = Builtins.maplist(@arch_directories) do |arch_dir|
        Ops.add(Ops.add(@full_data_path, "/"), arch_dir)
      end
      dirs_for_md5 = Builtins.add(dirs_for_md5, @full_descr_path)
      Builtins.foreach(dirs_for_md5) do |full_path|
        if dir_has_files(full_path)
          Builtins.y2milestone("creating MDBSUM in %1", full_path)
          # whole dir was copied -> also with original MD5SUMS
          if FileUtils.Exists(Ops.add(full_path, "/MD5SUMS"))
            SCR.Execute(
              path(".target.bash"),
              Builtins.sformat(
                "cd '%1'; chmod +w . MD5SUMS; rm MD5SUMS",
                full_path
              )
            )
          end
          command = Builtins.sformat(
            "cd '%1'; md5sum -- * > MD5SUMS",
            full_path
          )
          out2 = Convert.to_map(
            SCR.Execute(path(".target.bash_output"), command, { "LANG" => "C" })
          )
          if Ops.get_integer(out2, "exit", 0) != 0
            Builtins.y2error("%1 failed: %2", command, out2)
          end
        end
      end

      # sha1sums of descriptions
      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat("ls -A1 '%1'", @full_descr_path)
        )
      )
      Builtins.foreach(
        Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
      ) do |file|
        next if file == "" || file == "MD5SUMS"
        Builtins.y2milestone("creating sha1sum of %1", file)
        out = Convert.to_map(
          SCR.Execute(
            path(".target.bash_output"),
            Builtins.sformat(
              "cd '%1' && sha1sum -- %2",
              @full_descr_path,
              String.Quote(file)
            ),
            { "LANG" => "C" }
          )
        )
        command = Builtins.sformat(
          "echo 'META SHA1 %1' >> '%2/content'",
          Builtins.deletechars(Ops.get_string(out, "stdout", ""), "\n"),
          base_path
        )
        SCR.Execute(path(".target.bash"), command, { "LANG" => "C" })
      end

      # sha1sums of the rest of interesting files
      Builtins.foreach(
        [
          "installation.xml",
          "license.tar.gz",
          "y2update.tgz",
          "media.1/info.txt"
        ]
      ) do |file|
        if FileUtils.Exists(Ops.add(Ops.add(base_path, "/"), file))
          Builtins.y2milestone("creating sha1sum of %1", file)
          out = Convert.to_map(
            SCR.Execute(
              path(".target.bash_output"),
              Builtins.sformat(
                "cd '%1' && sha1sum -- %2",
                base_path,
                String.Quote(file)
              ),
              { "LANG" => "C" }
            )
          )
          command = Builtins.sformat(
            "echo 'HASH SHA1 %1' >> '%2/content'",
            Builtins.deletechars(Ops.get_string(out, "stdout", ""), "\n"),
            base_path
          )
          SCR.Execute(path(".target.bash"), command, { "LANG" => "C" })
        end
      end
      true
    end

    # Report the error with failed gpg and ask for possible new
    # entering of pw
    # @param [String] message from gpg
    # @param boolean if we are asking because of signing failure
    def AskForPassphrase(message, failure)
      pw = nil
      info_term = failure ?
        VBox(
          HSpacing(70),
          # error label
          Left(Label(_("Signing of the product failed."))),
          message == "" ?
            VSpacing(0) :
            RichText(
              Builtins.mergestring(
                Builtins.splitstring(String.EscapeTags(message), "\n"),
                "<br>"
              )
            )
        ) :
        VSpacing()
      input_term = failure ?
        HBox(
          Left(
            CheckBox(
              Id(:again),
              Opt(:notify),
              # checkbox label
              _("Try again with different passphrase")
            )
          ),
          Password(Id(:pw1), "")
        ) :
        VBox(Password(Id(:pw1), message))
      UI.OpenDialog(
        Opt(:decorated),
        HBox(
          HSpacing(0.5),
          VBox(
            info_term,
            input_term,
            PushButton(Id(:ok), Opt(:key_F10), Label.OKButton),
            VSpacing(0.5)
          ),
          HSpacing(0.5)
        )
      )
      UI.ChangeWidget(Id(:pw1), :Enabled, !failure)

      ret = :cancel
      begin
        ret = UI.UserInput
        if ret == :again
          enabled = Convert.to_boolean(UI.QueryWidget(Id(:pw1), :Enabled))
          UI.ChangeWidget(Id(:pw1), :Enabled, !enabled)
        end
        if ret == :ok
          if UI.QueryWidget(Id(:pw1), :Enabled) == true
            pw = Convert.to_string(UI.QueryWidget(Id(:pw1), :Value))
          end
        end
      end until ret == :ok || ret == :cancel

      UI.CloseDialog
      pw
    end

    # Sign current Add-On product
    # @param [String] base_path path to target product directory
    # @param [String] key GPG key to sign with
    def SignAddOn(base_path, key)
      passphrase = Ops.get_string(@passphrases, key, "")
      if key == "" || passphrase == ""
        Builtins.y2warning(
          "No GPG key or passphrase provided - signing skipped"
        )
        return true
      end

      command = Builtins.sformat(
        "gpg --list-secret-keys %1|grep '^sec'|sed -e 's/.*\\///;s/ .*//g;'|head -n 1",
        key
      )
      out = Convert.to_map(
        SCR.Execute(path(".target.bash_output"), command, { "LANG" => "C" })
      )
      local_key = Builtins.deletechars(Ops.get_string(out, "stdout", "0"), "\n")

      # see /usr/share/doc/packages/gpg2/DETAILS for gpg --list-secret-keys --with-colons
      # file name of exported key: keyid-creation date of the selfsignature (ie. e85fc3fc-4c1b74be)

      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat(
            "gpg --list-secret-keys --with-colons %1| grep %2 | gawk -F: '{print $6}'",
            key,
            local_key
          )
        )
      )

      creation_date = Builtins.tointeger(
        Builtins.deletechars(Ops.get_string(out, "stdout", "0"), "\n")
      )
      creation_date_s = Builtins.substring(
        Builtins.tohexstring(creation_date),
        2
      ) # use hex string without leading 0x

      # save the passphrase
      pw_path = Ops.add(@tmpdir, "/pw")
      SCR.Write(path(".target.string"), pw_path, passphrase)

      # export the key:
      command = Builtins.sformat(
        "gpg --export -a %1 > '%2/gpg-pubkey-%1-%3.asc'",
        Builtins.tolower(local_key),
        base_path,
        creation_date_s
      )
      SCR.Execute(path(".target.bash"), command, { "LANG" => "C" })

      # make a sha1 sum of that key (content file is modified last time)
      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat("cd '%1'; ls -A1 gpg-pubkey*", base_path)
        )
      )

      Builtins.foreach(
        Builtins.splitstring(Ops.get_string(out, "stdout", ""), "\n")
      ) do |file|
        next if file == ""
        out = Convert.to_map(
          SCR.Execute(
            path(".target.bash_output"),
            Builtins.sformat(
              "cd '%1' && sha1sum -- %2",
              base_path,
              String.Quote(file)
            ),
            { "LANG" => "C" }
          )
        )
        command2 = Builtins.sformat(
          "echo 'KEY SHA1 %1' >> '%2/content'",
          Builtins.deletechars(Ops.get_string(out, "stdout", ""), "\n"),
          base_path
        )
        SCR.Execute(path(".target.bash"), command2, { "LANG" => "C" })
      end
      Builtins.y2milestone("signing content file...")
      while true
        # sign the content file
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat("rm -f '%1/content.asc'", base_path)
        )
        out = Convert.to_map(
          SCR.Execute(
            path(".target.bash_output"),
            Builtins.sformat(
              "gpg --batch --no-tty --passphrase-fd 0 --detach-sign -u %1 -a '%2/content' < %3",
              local_key,
              base_path,
              pw_path
            )
          )
        )
        if Ops.get_integer(out, "exit", 0) != 0
          if Mode.commandline
            Report.Error(Ops.get_string(out, "stderr", ""))
          else
            passphrase = AskForPassphrase(
              Ops.get_string(out, "stderr", ""),
              true
            )
            if passphrase != nil
              SCR.Write(path(".target.string"), pw_path, passphrase)
              next
            end
          end
          SCR.Execute(path(".target.remove"), pw_path)
          Builtins.y2milestone("correct passphrase not provided")
          return false
        else
          break
        end
      end
      Builtins.y2milestone("... done")

      SCR.Execute(
        path(".target.bash"),
        Builtins.sformat(
          "gpg --export -a %1 > '%2/content.key'",
          local_key,
          base_path
        )
      )

      # sign the packages
      if Ops.get_boolean(@current_product, "resign_packages", false)
        Builtins.y2milestone("signing the packages...")
        expect = Ops.add(@tmpdir, "/sign.ex")
        SCR.Write(
          path(".target.string"),
          expect,
          Builtins.sformat(@expect_script, key, passphrase)
        )
        dirs = Builtins.maplist(@arch_directories) do |arch_dir|
          Ops.add(Ops.add(@full_data_path, "/"), arch_dir)
        end
        Builtins.foreach(dirs) do |full_path|
          if dir_has_files(full_path)
            cmd2 = Builtins.sformat(
              "LANG=C expect %1 %2/*.rpm",
              expect,
              full_path
            )
            out = Convert.to_map(SCR.Execute(path(".target.bash_output"), cmd2))
          end
        end
        Builtins.y2milestone("... done")
        SCR.Execute(path(".target.bash"), Builtins.sformat("rm %1", expect))
        # after signing packages checksums have been changed:
        # run create_package_descr again and take new 'packages' file
        Builtins.y2milestone("updating packages descriptions...")
        cmd = Builtins.sformat(
          "/usr/bin/create_package_descr -d %1 -C -F -o %2",
          @full_data_path,
          @tmpdir
        )
        if SCR.Execute(path(".target.bash"), cmd, { "LANG" => "C" }) == 0
          cmd = Builtins.sformat(
            "/bin/cp -- %1/packages '%2'",
            @tmpdir,
            @full_descr_path
          )
          SCR.Execute(path(".target.bash"), cmd, { "LANG" => "C" })
          if @compress_package_descriptions
            SCR.Execute(
              path(".target.bash"),
              Builtins.sformat("gzip %1/packages", @full_descr_path)
            )
          end
          # ... don't forget to update checksums of new packages file (bnc#484695)
          # 1. MD5SUMS in DESCR directory (probably obsolete anyway)
          SCR.Execute(
            path(".target.bash"),
            Builtins.sformat("rm -f %1/MD5SUMS", @full_descr_path)
          )
          cmd = Builtins.sformat(
            "cd '%1'; md5sum -- * > MD5SUMS",
            @full_descr_path
          )
          out = Convert.to_map(
            SCR.Execute(path(".target.bash_output"), cmd, { "LANG" => "C" })
          )
          if Ops.get_integer(out, "exit", 0) != 0
            Builtins.y2error("'%1' failed: %2", cmd, out)
          end
          # 2. SHA1SUM of 'packages' belongs to content file
          file = @compress_package_descriptions ? "packages.gz" : "packages"
          out = Convert.to_map(
            SCR.Execute(
              path(".target.bash_output"),
              Builtins.sformat(
                "cd '%1' && sha1sum -- %2",
                @full_descr_path,
                String.Quote(file)
              ),
              { "LANG" => "C" }
            )
          )
          sha1sum = Builtins.deletechars(
            Ops.get_string(out, "stdout", ""),
            "\n"
          )
          cmd = Builtins.sformat(
            "sed --in-place 's/^META SHA1 .* %1$/META SHA1 %2/' %3/content",
            file,
            sha1sum,
            base_path
          )
          out = Convert.to_map(
            SCR.Execute(path(".target.bash_output"), cmd, { "LANG" => "C" })
          )
          if Ops.get_integer(out, "exit", 0) != 0
            Builtins.y2error("'%1' failed: %2", cmd, out)
          else
            Builtins.y2milestone("'content' modified, signing it again...")
            # 3. finally, sign the content file again...
            # (alternatively, content could be signed as the last step,
            # but there's some nice functionality to really ask for correct password
            # at the beginning of the function...)
            SCR.Execute(
              path(".target.bash"),
              Builtins.sformat("rm -f '%1/content.asc'", base_path)
            )
            cmd = Builtins.sformat(
              "gpg --batch --no-tty --passphrase-fd 0 --detach-sign -u %1 -a '%2/content' < %3",
              local_key,
              base_path,
              pw_path
            )
            out = Convert.to_map(
              SCR.Execute(path(".target.bash_output"), cmd, { "LANG" => "C" })
            )
            if Ops.get_integer(out, "exit", 0) != 0
              Builtins.y2error("'%1' failed: %2", cmd, out)
            end
            Builtins.y2milestone("... done")
          end
        else
          Builtins.y2warning("'%1' failed", cmd)
        end
        Builtins.y2milestone("... done (packages descriptions)")
      end

      # sign products file
      products_path = Ops.add(Ops.get(@full_media_paths, 0, ""), "/products")
      if FileUtils.Exists(products_path)
        Builtins.y2milestone("signing products file...")
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat("rm -f '%1.asc'", products_path)
        )
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat(
            "gpg --batch --no-tty --passphrase-fd 0 --detach-sign -u %1 -a '%2' < %3",
            local_key,
            products_path,
            pw_path
          )
        )
        SCR.Execute(
          path(".target.bash"),
          Builtins.sformat(
            "gpg --export -a %1 > '%2.key'",
            local_key,
            products_path
          )
        )
        Builtins.y2milestone("... done")
      end
      SCR.Execute(path(".target.remove"), pw_path)
      true
    end

    # Create directory.yast files (the last step)
    # @return success
    def CreateDirectoryYaSTFiles(base_path)
      return false if !FileUtils.Exists(base_path)

      Builtins.y2milestone("creating directory.yast files...")
      Builtins.foreach(
        Convert.convert(
          Builtins.merge([base_path, @full_descr_path], @full_media_paths),
          :from => "list",
          :to   => "list <string>"
        )
      ) do |dir|
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat(
            "cd '%1'; ls -A1 -p | grep -v 'directory.yast' > directory.yast",
            dir
          ),
          { "LANG" => "C" }
        )
      end
      Builtins.y2milestone("... done")
      true
    end

    # Create an ISO image of the product
    def CreateISOImage(dir_path, iso_p, name)
      return true if !Ops.get_boolean(@current_product, "iso", false)

      return false if !FileUtils.Exists(dir_path) || !FileUtils.Exists(iso_p)

      if name == ""
        name = Builtins.sformat(
          "%1-%2",
          Builtins.tolower(Ops.get(@content_map, "NAME", "addon")),
          Ops.get(@content_map, "VERSION", "")
        )
      end
      name = Ops.add(name, ".iso") if !Builtins.issubstring(name, ".iso")
      Ops.set(@current_product, "iso_name", name) # ??

      Builtins.y2milestone(
        "creating iso image '%1/%2' from '%3' with mkisofs...",
        iso_p,
        name,
        dir_path
      )

      # possible options -allow-leading-dots
      cmd = Builtins.sformat(
        "mkisofs -r -J -l -o '%1/%2' '%3'",
        iso_p,
        name,
        dir_path
      )
      out = Convert.to_map(SCR.Execute(path(".target.bash_output"), cmd))
      if Ops.get_integer(out, "exit", 0) != 0
        Builtins.y2warning("%1 returned %2", cmd, out)
      end
      Builtins.y2milestone("... done")
      true
    end

    # Reset all settings related to current product
    def ResetCurrentProduct
      @current_product = deep_copy(@current_product_skel)
      @generate_descriptions = false
      @clone = false

      @available_packages = {}
      @package2filename = {}
      @srcpackage2filename = {}

      # TODO move into current_product as well?
      @content = []
      @content_map = {}

      # reset global variables, that are generated for each product
      @full_media_paths = []
      @full_descr_path = ""
      @full_data_path = ""

      nil
    end

    # save the data with current configuration into global list
    # + reset the current product map
    def CommitCurrentProduct
      Builtins.y2milestone("saving current product to the global list")

      product_info_values = {}
      Builtins.foreach(@product_info) do |key, desc|
        if Ops.get(desc, "value") != nil
          Ops.set(
            product_info_values,
            key,
            { "value" => Ops.get(desc, "value") }
          )
        end
      end
      modified_product = Builtins.union(
        @current_product, # Commit is after everything was entered
        {
          "content_map"         => @content_map,
          "product_info_values" => product_info_values,
          "available_packages"  => @available_packages,
          "arch_directories"    => @arch_directories,
          "package2filename"    => @package2filename,
          "srcpackage2filename" => @srcpackage2filename,
          "generated"           => true
        }
      )
      if @selected_product == -1
        @add_on_products = Builtins.add(@add_on_products, modified_product)
      else
        i = -1
        @add_on_products = Builtins.maplist(@add_on_products) do |product|
          i = Ops.add(i, 1)
          i == @selected_product ?
            deep_copy(modified_product) :
            deep_copy(product)
        end
      end
      ResetCurrentProduct()
      @modified = true

      nil
    end

    # select the given product:
    # fill in the global variables specific for the given product
    def SelectProduct(product)
      product = deep_copy(product)
      @current_product = deep_copy(product)
      @content_map = Ops.get_map(product, "content_map", {})
      product_info_values = Ops.get_map(product, "product_info_values", {})

      Builtins.foreach(@product_info_descr) do |key, desc|
        if Ops.get(product_info_values, [key, "value"]) != nil
          Ops.set(desc, "value", Ops.get(product_info_values, [key, "value"]))
        end
        Ops.set(@product_info, key, desc)
      end

      # generate content from content_map
      @content = []
      Builtins.foreach(@content_descr) do |key, entry|
        if Ops.get(@content_map, key, "") != ""
          Ops.set(entry, "value", Ops.get(@content_map, key, ""))
        end
        @content = Builtins.add(@content, entry)
      end
      Builtins.foreach(@content_map) do |key, val|
        if !Builtins.haskey(@content_descr, key) &&
            Builtins.issubstring(key, ".")
          Builtins.y2debug("key %1 not in descr", key)
          entry = Ops.get_map(
            @content_specials,
            Builtins.substring(key, 0, Builtins.findfirstof(key, ".")),
            {}
          )
          Ops.set(entry, "key", key)
          Ops.set(entry, "value", val)
          @content = Builtins.add(@content, entry)
        end
      end
      @available_packages = Ops.get_map(product, "available_packages", {})
      @arch_directories = Ops.get_list(product, "arch_directories", [])
      @package2filename = Ops.get_map(product, "package2filename", {})
      @srcpackage2filename = Ops.get_map(product, "srcpackage2filename", {})

      nil
    end

    # Write all AddOn products configurations
    def Write
      @add_on_products = Builtins.maplist(@add_on_products) do |product|
        # these could be generated, no need to save...
        Builtins.foreach(
          [
            "available_packages",
            "arch_directories",
            "package2filename",
            "srcpackage2filename",
            "generated"
          ]
        ) do |key|
          if Builtins.haskey(product, key)
            product = Builtins.remove(product, key)
          end
        end
        deep_copy(product)
      end
      Builtins.y2milestone("writing list of configured products")
      SCR.Write(path(".target.ycp"), @add_on_products_file, @add_on_products)
    end

    # read the user's ID for given GPG key
    def GetKeyUID(key)
      out = Convert.to_map(
        SCR.Execute(
          path(".target.bash_output"),
          Builtins.sformat(
            "gpg --list-secret-keys %1 | grep uid | sed -e 's/^uid[ ]*//'",
            key
          )
        )
      )
      name = Builtins.deletechars(Ops.get_string(out, "stdout", ""), "\n")
      name == nil ? "" : name
    end

    # prepare the data of current product for a build
    # (neccessary because input packages could get changed)
    def PrepareBuild
      if !Ops.get_boolean(@current_product, "generated", false)
        FillContentDefaults() 
        # TODO not everything generated by FillContentDefaults is needed?
      end
      key = Ops.get_string(@current_product, "gpg_key", "")
      if Ops.get_boolean(@current_product, "ask_for_passphrase", false) &&
          key != "" &&
          Ops.get_string(@passphrases, key, "") == "" &&
          !Mode.commandline
        name = GetKeyUID(key)
        # ask for pw now %1 is key id, %2 user name
        Ops.set(
          @passphrases,
          key,
          AskForPassphrase(
            Builtins.sformat(
              _("Enter passphrase for GPG key %1\n(%2)"),
              key,
              name
            ),
            false
          )
        )
      end

      nil
    end

    # Write all add-on-creator settings
    # @return true on success
    def BuildAddOn
      base_output_path = Ops.get_string(
        @current_product,
        "base_output_path",
        ""
      )

      # AddOnCreator Build dialog caption
      caption = _("Creating the Add-On")

      stages = [
        # Progress stage
        _("Write the content file"),
        # Progress stage
        _("Create the structure of the add-on"),
        # Progress stage
        _("Write the patterns"),
        # Progress stage
        _("Copy the packages"),
        # Progress stage
        _("Generate the release package"),
        # Progress stage
        _("Create MD5 sums"),
        # Progress stage
        _("Sign resulting product")
      ]
      steps = [
        # Progress step
        _("Writing the content file..."),
        # Progress step
        _("Creating the structure of the add-on..."),
        # Progress stage
        _("Writing the patterns..."),
        # Progress step
        _("Copying the packages..."),
        # Progress stage
        _("Generating the release package..."),
        # Progress step
        _("Creating MD5 sums..."),
        # Progress stage
        _("Signing resulting product...")
      ]

      if Ops.get_boolean(@current_product, "iso", false)
        # Progress stage
        stages = Builtins.add(stages, _("Create ISO image"))
        # Progress step
        steps = Builtins.add(steps, _("Creating ISO image..."))
      end
      # Progress finished
      steps = Builtins.add(steps, _("Finished"))

      Progress.New(caption, " ", Builtins.size(stages), stages, steps, "")

      Progress.NextStage

      # when building ISO, target directory is defined by iso_path:
      # let's use base_output_path for gathering data needed for iso creation
      if Ops.get_boolean(@current_product, "iso", false)
        iso_path = Ops.get_string(@current_product, "iso_path", "")
        if iso_path == ""
          Ops.set(@current_product, "iso_path", base_output_path)
          if !@only_sign_product
            base_output_path = Ops.add(@tmpdir, "/output")
            if FileUtils.Exists(base_output_path)
              SCR.Execute(
                path(".target.bash"),
                Builtins.sformat("/bin/rm -rf '%1'", base_output_path)
              )
            end
            SCR.Execute(path(".target.mkdir"), base_output_path)
          end
        elsif !FileUtils.Exists(iso_path)
          SCR.Execute(path(".target.mkdir"), iso_path)
        end
      end

      if @only_sign_product
        GenerateDirectories(base_output_path)
        Progress.NextStage
        Progress.NextStage
        Progress.NextStage
        Progress.NextStage
      else
        if !WriteContentFile(base_output_path, @content)
          # Error message (do not translate 'content'
          Report.Error(_("Cannot write content file."))
          return false
        end

        WriteStringFiles(
          base_output_path,
          Ops.get_map(@current_product, "readme_files", {})
        )
        WriteStringFiles(
          base_output_path,
          Ops.get_map(@current_product, "copying_files", {})
        )
        WriteStringFiles(
          base_output_path,
          Ops.get_map(@current_product, "copyright_files", {})
        )

        Progress.NextStage

        if !CreateAddOnStructure(base_output_path)
          # Error message
          Report.Error(_("Cannot create the output directory structure."))
          return false
        end

        WritePatchesFiles(
          base_output_path,
          Ops.get_list(@current_product, "patches_files", [])
        )

        WriteProductsFiles(
          base_output_path,
          Ops.get_list(@current_product, "products_files", [])
        )

        WriteMediaFiles(
          base_output_path,
          Ops.get_list(@current_product, "media_files", []),
          Ops.get_string(@current_product, "nextmedia", "")
        )

        WriteInfoFile(
          Ops.get(@full_media_paths, 0, ""),
          Ops.get_string(@current_product, "info", "")
        )

        Progress.NextStage

        WritePatterns(@full_descr_path, base_output_path)

        Progress.NextStage

        CopyRPMs(
          Ops.get_string(@current_product, "rpm_path", ""),
          base_output_path
        )

        Progress.NextStage

        GenerateReleasePackage(base_output_path)

        WritePackageDescriptions(
          @full_descr_path,
          Ops.get_map(@current_product, "packages_descr", {})
        )

        WriteLicensesFiles(
          @full_descr_path,
          base_output_path,
          Ops.get_map(@current_product, "license_files", {})
        )

        WriteWorkflow(
          base_output_path,
          Ops.get_string(@current_product, "workflow_path", ""),
          Ops.get_list(@current_product, "y2update_packages", []),
          Ops.get_string(@current_product, "y2update_path", "")
        )

        Progress.NextStage

        GenerateArchiveFiles(base_output_path)

        CreateMD5SUMS(base_output_path)
      end

      Progress.NextStage

      if Ops.get_boolean(@current_product, "changelog", false)
        GenerateChangelog(base_output_path)
      end

      WriteServicepackArchive(base_output_path)

      if !SignAddOn(
          base_output_path,
          Ops.get_string(@current_product, "gpg_key", "")
        )
        return false
      end

      CreateDirectoryYaSTFiles(base_output_path)

      if Ops.get_boolean(@current_product, "iso", false)
        Progress.NextStage
        CreateISOImage(
          base_output_path,
          Ops.get_string(@current_product, "iso_path", ""),
          Ops.get_string(@current_product, "iso_name", "")
        )
      end

      Progress.NextStage

      ResetCurrentProduct()

      true
    end

    # Export the settings about current Add-On product
    def Export
      Builtins.y2warning("not implemented")
      {}
    end

    def Import(settings)
      settings = deep_copy(settings)
      Builtins.y2warning("not implemented")
      false
    end

    publish :variable => :add_on_products, :type => "list <map>"
    publish :variable => :current_product, :type => "map"
    publish :variable => :selected_product, :type => "integer"
    publish :variable => :content, :type => "list <map>"
    publish :variable => :allowed_archs, :type => "list <string>"
    publish :variable => :content_specials, :type => "map"
    publish :variable => :pattern_descr, :type => "map <string, map>"
    publish :variable => :description_descr, :type => "map <string, map>"
    publish :variable => :content_map, :type => "map <string, string>"
    publish :variable => :product_info_descr, :type => "map <string, map>"
    publish :variable => :product_info, :type => "map <string, map>"
    publish :variable => :product_xml, :type => "map"
    publish :variable => :clone, :type => "boolean"
    publish :variable => :import_path, :type => "string"
    publish :variable => :generate_descriptions, :type => "boolean"
    publish :variable => :bootable, :type => "boolean"
    publish :variable => :passphrases, :type => "map"
    publish :variable => :gpg_keys, :type => "list <string>"
    publish :variable => :available_packages, :type => "map <string, list>"
    publish :variable => :package2filename, :type => "map <string, map>"
    publish :variable => :srcpackage2filename, :type => "map <string, map>"
    publish :variable => :only_sign_product, :type => "boolean"
    publish :variable => :compress_patterns, :type => "boolean"
    publish :variable => :merge_patterns, :type => "boolean"
    publish :variable => :compress_package_descriptions, :type => "boolean"
    publish :variable => :modified, :type => "boolean"
    publish :variable => :content_key, :type => "string"
    publish :function => :Modified, :type => "boolean ()"
    publish :function => :ReadProductXML, :type => "map <string, any> (string)"
    publish :function => :GetProductInfo, :type => "map <string, map> (map, boolean)"
    publish :function => :UpdateContentMap, :type => "map <string, string> (list <map>)"
    publish :function => :GetLangCodes, :type => "list <string> (boolean)"
    publish :function => :CreatePatternFullName, :type => "string (map, boolean)"
    publish :function => :GenerateGPGKey, :type => "string (map <string, string>)"
    publish :function => :Read, :type => "boolean ()"
    publish :function => :ReadContentFile, :type => "list <map> (string)"
    publish :function => :ReadPatternFile, :type => "map (string)"
    publish :function => :ReadPatternsFile, :type => "list <map> (string)"
    publish :function => :ReadPackagesFile, :type => "map (string)"
    publish :function => :ImportExistingProduct, :type => "boolean (string)"
    publish :function => :FillContentDefaults, :type => "void ()"
    publish :function => :WriteContentFile, :type => "boolean (string, list <map>)"
    publish :function => :WriteStringFiles, :type => "boolean (string, map <string, string>)"
    publish :function => :GenerateDirectories, :type => "void (string)"
    publish :function => :CreateAddOnStructure, :type => "boolean (string)"
    publish :function => :GeneratePackageDescriptions, :type => "boolean ()"
    publish :function => :WritePackageDescriptions, :type => "boolean (string, map)"
    publish :function => :GenerateArchiveFiles, :type => "boolean (string)"
    publish :function => :WritePatchesFiles, :type => "boolean (string, list <string>)"
    publish :function => :WriteProductsFiles, :type => "boolean (string, list <string>)"
    publish :function => :WriteMediaFiles, :type => "boolean (string, list <string>, string)"
    publish :function => :WriteInfoFile, :type => "boolean (string, string)"
    publish :function => :WriteLicensesFiles, :type => "boolean (string, string, map <string, string>)"
    publish :function => :WritePatterns, :type => "boolean (string, string)"
    publish :function => :CopyRPMs, :type => "boolean (string, string)"
    publish :function => :GenerateReleasePackage, :type => "boolean (string)"
    publish :function => :CreateMD5SUMS, :type => "boolean (string)"
    publish :function => :SignAddOn, :type => "boolean (string, string)"
    publish :function => :CreateDirectoryYaSTFiles, :type => "boolean (string)"
    publish :function => :CreateISOImage, :type => "boolean (string, string, string)"
    publish :function => :ResetCurrentProduct, :type => "void ()"
    publish :function => :CommitCurrentProduct, :type => "void ()"
    publish :function => :SelectProduct, :type => "void (map)"
    publish :function => :Write, :type => "boolean ()"
    publish :function => :GetKeyUID, :type => "string (string)"
    publish :function => :PrepareBuild, :type => "boolean ()"
    publish :function => :BuildAddOn, :type => "boolean ()"
    publish :function => :Export, :type => "map ()"
    publish :function => :Import, :type => "boolean (map)"
  end

  AddOnCreator = AddOnCreatorClass.new
  AddOnCreator.main
end
